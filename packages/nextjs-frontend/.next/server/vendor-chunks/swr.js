"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/swr";
exports.ids = ["vendor-chunks/swr"];
exports.modules = {

/***/ "(ssr)/../../node_modules/swr/dist/index.mjs":
/*!*********************************************!*\
  !*** ../../node_modules/swr/dist/index.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SWRConfig: () => (/* binding */ SWRConfig),\n/* harmony export */   \"default\": () => (/* binding */ useSWR),\n/* harmony export */   mutate: () => (/* binding */ mutate),\n/* harmony export */   unstable_serialize: () => (/* binding */ unstable_serialize),\n/* harmony export */   useSWRConfig: () => (/* binding */ useSWRConfig)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __generator(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nvar noop = function() {};\n// Using noop() as the undefined value as undefined can possibly be replaced\n// by something else.  Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nvar UNDEFINED = /*#__NOINLINE__*/ noop();\nvar OBJECT = Object;\nvar isUndefined = function(v) {\n    return v === UNDEFINED;\n};\nvar isFunction = function(v) {\n    return typeof v == \"function\";\n};\nvar mergeObjects = function(a, b) {\n    return OBJECT.assign({}, a, b);\n};\nvar STR_UNDEFINED = \"undefined\";\n// NOTE: Use function to guarantee it's re-evaluated between jsdom and node runtime for tests.\nvar hasWindow = function() {\n    return \"undefined\" != STR_UNDEFINED;\n};\nvar hasDocument = function() {\n    return typeof document != STR_UNDEFINED;\n};\nvar hasRequestAnimationFrame = function() {\n    return hasWindow() && typeof window[\"requestAnimationFrame\"] != STR_UNDEFINED;\n};\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nvar table = new WeakMap();\n// counter of the key\nvar counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsible.\nvar stableHash = function(arg) {\n    var type = typeof arg;\n    var constructor = arg && arg.constructor;\n    var isDate = constructor == Date;\n    var result;\n    var index;\n    if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {\n        // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n        // If it's already hashed, directly return the result.\n        result = table.get(arg);\n        if (result) return result;\n        // Store the hash first for circular reference detection before entering the\n        // recursive `stableHash` calls.\n        // For other objects like set and map, we use this id directly as the hash.\n        result = ++counter + \"~\";\n        table.set(arg, result);\n        if (constructor == Array) {\n            // Array.\n            result = \"@\";\n            for(index = 0; index < arg.length; index++){\n                result += stableHash(arg[index]) + \",\";\n            }\n            table.set(arg, result);\n        }\n        if (constructor == OBJECT) {\n            // Object, sort keys.\n            result = \"#\";\n            var keys = OBJECT.keys(arg).sort();\n            while(!isUndefined(index = keys.pop())){\n                if (!isUndefined(arg[index])) {\n                    result += index + \":\" + stableHash(arg[index]) + \",\";\n                }\n            }\n            table.set(arg, result);\n        }\n    } else {\n        result = isDate ? arg.toJSON() : type == \"symbol\" ? arg.toString() : type == \"string\" ? JSON.stringify(arg) : \"\" + arg;\n    }\n    return result;\n};\n/**\n * Due to bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,\n * it's not reliable to detect if the browser is currently online or offline\n * based on `navigator.onLine`.\n * As a work around, we always assume it's online on first load, and change\n * the status upon `online` or `offline` events.\n */ var online = true;\nvar isOnline = function() {\n    return online;\n};\nvar hasWin = hasWindow();\nvar hasDoc = hasDocument();\n// For node and React Native, `add/removeEventListener` doesn't exist on window.\nvar onWindowEvent = hasWin && window.addEventListener ? window.addEventListener.bind(window) : noop;\nvar onDocumentEvent = hasDoc ? document.addEventListener.bind(document) : noop;\nvar offWindowEvent = hasWin && window.removeEventListener ? window.removeEventListener.bind(window) : noop;\nvar offDocumentEvent = hasDoc ? document.removeEventListener.bind(document) : noop;\nvar isVisible = function() {\n    var visibilityState = hasDoc && document.visibilityState;\n    return isUndefined(visibilityState) || visibilityState !== \"hidden\";\n};\nvar initFocus = function(callback) {\n    // focus revalidate\n    onDocumentEvent(\"visibilitychange\", callback);\n    onWindowEvent(\"focus\", callback);\n    return function() {\n        offDocumentEvent(\"visibilitychange\", callback);\n        offWindowEvent(\"focus\", callback);\n    };\n};\nvar initReconnect = function(callback) {\n    // revalidate on reconnected\n    var onOnline = function() {\n        online = true;\n        callback();\n    };\n    // nothing to revalidate, just update the status\n    var onOffline = function() {\n        online = false;\n    };\n    onWindowEvent(\"online\", onOnline);\n    onWindowEvent(\"offline\", onOffline);\n    return function() {\n        offWindowEvent(\"online\", onOnline);\n        offWindowEvent(\"offline\", onOffline);\n    };\n};\nvar preset = {\n    isOnline: isOnline,\n    isVisible: isVisible\n};\nvar defaultConfigOptions = {\n    initFocus: initFocus,\n    initReconnect: initReconnect\n};\nvar IS_SERVER = !hasWindow() || \"Deno\" in window;\n// Polyfill requestAnimationFrame\nvar rAF = function(f) {\n    return hasRequestAnimationFrame() ? window[\"requestAnimationFrame\"](f) : setTimeout(f, 1);\n};\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nvar useIsomorphicLayoutEffect = IS_SERVER ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\n// This assignment is to extend the Navigator type to use effectiveType.\nvar navigatorConnection = typeof navigator !== \"undefined\" && navigator.connection;\n// Adjust the config based on slow connection status (<= 70Kbps).\nvar slowConnection = !IS_SERVER && navigatorConnection && ([\n    \"slow-2g\",\n    \"2g\"\n].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);\nvar serialize = function(key) {\n    if (isFunction(key)) {\n        try {\n            key = key();\n        } catch (err) {\n            // dependencies not ready\n            key = \"\";\n        }\n    }\n    var args = [].concat(key);\n    // If key is not falsy, or not an empty array, hash it.\n    key = typeof key == \"string\" ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : \"\";\n    var infoKey = key ? \"$swr$\" + key : \"\";\n    return [\n        key,\n        args,\n        infoKey\n    ];\n};\n// Global state used to deduplicate requests and store listeners\nvar SWRGlobalState = new WeakMap();\nvar FOCUS_EVENT = 0;\nvar RECONNECT_EVENT = 1;\nvar MUTATE_EVENT = 2;\nvar broadcastState = function(cache, key, data, error, isValidating, revalidate, broadcast) {\n    if (broadcast === void 0) {\n        broadcast = true;\n    }\n    var _a = SWRGlobalState.get(cache), EVENT_REVALIDATORS = _a[0], STATE_UPDATERS = _a[1], FETCH = _a[3];\n    var revalidators = EVENT_REVALIDATORS[key];\n    var updaters = STATE_UPDATERS[key];\n    // Cache was populated, update states of all hooks.\n    if (broadcast && updaters) {\n        for(var i = 0; i < updaters.length; ++i){\n            updaters[i](data, error, isValidating);\n        }\n    }\n    // If we also need to revalidate, only do it for the first hook.\n    if (revalidate) {\n        // Invalidate the key by deleting the concurrent request markers so new\n        // requests will not be deduped.\n        delete FETCH[key];\n        if (revalidators && revalidators[0]) {\n            return revalidators[0](MUTATE_EVENT).then(function() {\n                return cache.get(key);\n            });\n        }\n    }\n    return cache.get(key);\n};\n// Global timestamp.\nvar __timestamp = 0;\nvar getTimestamp = function() {\n    return ++__timestamp;\n};\nvar internalMutate = function() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    return __awaiter(void 0, void 0, void 0, function() {\n        var cache, _key, _data, _opts, options, populateCache, revalidate, rollbackOnError, customOptimisticData, _a, key, keyInfo, _b, MUTATION, data, error, beforeMutationTs, hasCustomOptimisticData, rollbackData, optimisticData, res;\n        return __generator(this, function(_c) {\n            switch(_c.label){\n                case 0:\n                    cache = args[0], _key = args[1], _data = args[2], _opts = args[3];\n                    options = typeof _opts === \"boolean\" ? {\n                        revalidate: _opts\n                    } : _opts || {};\n                    populateCache = isUndefined(options.populateCache) ? true : options.populateCache;\n                    revalidate = options.revalidate !== false;\n                    rollbackOnError = options.rollbackOnError !== false;\n                    customOptimisticData = options.optimisticData;\n                    _a = serialize(_key), key = _a[0], keyInfo = _a[2];\n                    if (!key) return [\n                        2 /*return*/ \n                    ];\n                    _b = SWRGlobalState.get(cache), MUTATION = _b[2];\n                    // If there is no new data provided, revalidate the key with current state.\n                    if (args.length < 3) {\n                        // Revalidate and broadcast state.\n                        return [\n                            2 /*return*/ ,\n                            broadcastState(cache, key, cache.get(key), UNDEFINED, UNDEFINED, revalidate, true)\n                        ];\n                    }\n                    data = _data;\n                    beforeMutationTs = getTimestamp();\n                    MUTATION[key] = [\n                        beforeMutationTs,\n                        0\n                    ];\n                    hasCustomOptimisticData = !isUndefined(customOptimisticData);\n                    rollbackData = cache.get(key);\n                    // Do optimistic data update.\n                    if (hasCustomOptimisticData) {\n                        optimisticData = isFunction(customOptimisticData) ? customOptimisticData(rollbackData) : customOptimisticData;\n                        cache.set(key, optimisticData);\n                        broadcastState(cache, key, optimisticData);\n                    }\n                    if (isFunction(data)) {\n                        // `data` is a function, call it passing current cache value.\n                        try {\n                            data = data(cache.get(key));\n                        } catch (err) {\n                            // If it throws an error synchronously, we shouldn't update the cache.\n                            error = err;\n                        }\n                    }\n                    if (!(data && isFunction(data.then))) return [\n                        3 /*break*/ ,\n                        2\n                    ];\n                    return [\n                        4 /*yield*/ ,\n                        data.catch(function(err) {\n                            error = err;\n                        })\n                    ];\n                case 1:\n                    // This means that the mutation is async, we need to check timestamps to\n                    // avoid race conditions.\n                    data = _c.sent();\n                    // Check if other mutations have occurred since we've started this mutation.\n                    // If there's a race we don't update cache or broadcast the change,\n                    // just return the data.\n                    if (beforeMutationTs !== MUTATION[key][0]) {\n                        if (error) throw error;\n                        return [\n                            2 /*return*/ ,\n                            data\n                        ];\n                    } else if (error && hasCustomOptimisticData && rollbackOnError) {\n                        // Rollback. Always populate the cache in this case but without\n                        // transforming the data.\n                        populateCache = true;\n                        data = rollbackData;\n                        cache.set(key, rollbackData);\n                    }\n                    _c.label = 2;\n                case 2:\n                    // If we should write back the cache after request.\n                    if (populateCache) {\n                        if (!error) {\n                            // Transform the result into data.\n                            if (isFunction(populateCache)) {\n                                data = populateCache(data, rollbackData);\n                            }\n                            // Only update cached data if there's no error. Data can be `undefined` here.\n                            cache.set(key, data);\n                        }\n                        // Always update or reset the error.\n                        cache.set(keyInfo, mergeObjects(cache.get(keyInfo), {\n                            error: error\n                        }));\n                    }\n                    // Reset the timestamp to mark the mutation has ended.\n                    MUTATION[key][1] = getTimestamp();\n                    return [\n                        4 /*yield*/ ,\n                        broadcastState(cache, key, data, error, UNDEFINED, revalidate, !!populateCache)\n                    ];\n                case 3:\n                    res = _c.sent();\n                    // Throw error or return data\n                    if (error) throw error;\n                    return [\n                        2 /*return*/ ,\n                        populateCache ? res : data\n                    ];\n            }\n        });\n    });\n};\nvar revalidateAllKeys = function(revalidators, type) {\n    for(var key in revalidators){\n        if (revalidators[key][0]) revalidators[key][0](type);\n    }\n};\nvar initCache = function(provider, options) {\n    // The global state for a specific provider will be used to deduplicate\n    // requests and store listeners. As well as a mutate function that bound to\n    // the cache.\n    // Provider's global state might be already initialized. Let's try to get the\n    // global state associated with the provider first.\n    if (!SWRGlobalState.has(provider)) {\n        var opts = mergeObjects(defaultConfigOptions, options);\n        // If there's no global state bound to the provider, create a new one with the\n        // new mutate function.\n        var EVENT_REVALIDATORS = {};\n        var mutate = internalMutate.bind(UNDEFINED, provider);\n        var unmount = noop;\n        // Update the state if it's new, or the provider has been extended.\n        SWRGlobalState.set(provider, [\n            EVENT_REVALIDATORS,\n            {},\n            {},\n            {},\n            mutate\n        ]);\n        // This is a new provider, we need to initialize it and setup DOM events\n        // listeners for `focus` and `reconnect` actions.\n        if (!IS_SERVER) {\n            // When listening to the native events for auto revalidations,\n            // we intentionally put a delay (setTimeout) here to make sure they are\n            // fired after immediate JavaScript executions, which can possibly be\n            // React's state updates.\n            // This avoids some unnecessary revalidations such as\n            // https://github.com/vercel/swr/issues/1680.\n            var releaseFocus_1 = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));\n            var releaseReconnect_1 = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));\n            unmount = function() {\n                releaseFocus_1 && releaseFocus_1();\n                releaseReconnect_1 && releaseReconnect_1();\n                // When un-mounting, we need to remove the cache provider from the state\n                // storage too because it's a side-effect. Otherwise when re-mounting we\n                // will not re-register those event listeners.\n                SWRGlobalState.delete(provider);\n            };\n        }\n        // We might want to inject an extra layer on top of `provider` in the future,\n        // such as key serialization, auto GC, etc.\n        // For now, it's just a `Map` interface without any modifications.\n        return [\n            provider,\n            mutate,\n            unmount\n        ];\n    }\n    return [\n        provider,\n        SWRGlobalState.get(provider)[4]\n    ];\n};\n// error retry\nvar onErrorRetry = function(_, __, config, revalidate, opts) {\n    var maxRetryCount = config.errorRetryCount;\n    var currentRetryCount = opts.retryCount;\n    // Exponential backoff\n    var timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;\n    if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {\n        return;\n    }\n    setTimeout(revalidate, timeout, opts);\n};\n// Default cache provider\nvar _a = initCache(new Map()), cache = _a[0], mutate = _a[1];\n// Default config\nvar defaultConfig = mergeObjects({\n    // events\n    onLoadingSlow: noop,\n    onSuccess: noop,\n    onError: noop,\n    onErrorRetry: onErrorRetry,\n    onDiscarded: noop,\n    // switches\n    revalidateOnFocus: true,\n    revalidateOnReconnect: true,\n    revalidateIfStale: true,\n    shouldRetryOnError: true,\n    // timeouts\n    errorRetryInterval: slowConnection ? 10000 : 5000,\n    focusThrottleInterval: 5 * 1000,\n    dedupingInterval: 2 * 1000,\n    loadingTimeout: slowConnection ? 5000 : 3000,\n    // providers\n    compare: function(currentData, newData) {\n        return stableHash(currentData) == stableHash(newData);\n    },\n    isPaused: function() {\n        return false;\n    },\n    cache: cache,\n    mutate: mutate,\n    fallback: {}\n}, // use web preset by default\npreset);\nvar mergeConfigs = function(a, b) {\n    // Need to create a new object to avoid mutating the original here.\n    var v = mergeObjects(a, b);\n    // If two configs are provided, merge their `use` and `fallback` options.\n    if (b) {\n        var u1 = a.use, f1 = a.fallback;\n        var u2 = b.use, f2 = b.fallback;\n        if (u1 && u2) {\n            v.use = u1.concat(u2);\n        }\n        if (f1 && f2) {\n            v.fallback = mergeObjects(f1, f2);\n        }\n    }\n    return v;\n};\nvar SWRConfigContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nvar SWRConfig$1 = function(props) {\n    var value = props.value;\n    // Extend parent context values and middleware.\n    var extendedConfig = mergeConfigs((0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext), value);\n    // Should not use the inherited provider.\n    var provider = value && value.provider;\n    // Use a lazy initialized state to create the cache on first access.\n    var cacheContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function() {\n        return provider ? initCache(provider(extendedConfig.cache || cache), value) : UNDEFINED;\n    })[0];\n    // Override the cache if a new provider is given.\n    if (cacheContext) {\n        extendedConfig.cache = cacheContext[0];\n        extendedConfig.mutate = cacheContext[1];\n    }\n    // Unsubscribe events.\n    useIsomorphicLayoutEffect(function() {\n        return cacheContext ? cacheContext[2] : UNDEFINED;\n    }, []);\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(SWRConfigContext.Provider, mergeObjects(props, {\n        value: extendedConfig\n    }));\n};\n/**\n * An implementation of state with dependency-tracking.\n */ var useStateWithDeps = function(state, unmountedRef) {\n    var rerender = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({})[1];\n    var stateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state);\n    // If a state property (data, error or isValidating) is accessed by the render\n    // function, we mark the property as a dependency so if it is updated again\n    // in the future, we trigger a rerender.\n    // This is also known as dependency-tracking.\n    var stateDependenciesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        data: false,\n        error: false,\n        isValidating: false\n    });\n    /**\n     * @param payload To change stateRef, pass the values explicitly to setState:\n     * @example\n     * ```js\n     * setState({\n     *   isValidating: false\n     *   data: newData // set data to newData\n     *   error: undefined // set error to undefined\n     * })\n     *\n     * setState({\n     *   isValidating: false\n     *   data: undefined // set data to undefined\n     *   error: err // set error to err\n     * })\n     * ```\n     */ var setState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(payload) {\n        var shouldRerender = false;\n        var currentState = stateRef.current;\n        for(var _ in payload){\n            var k = _;\n            // If the property has changed, update the state and mark rerender as\n            // needed.\n            if (currentState[k] !== payload[k]) {\n                currentState[k] = payload[k];\n                // If the property is accessed by the component, a rerender should be\n                // triggered.\n                if (stateDependenciesRef.current[k]) {\n                    shouldRerender = true;\n                }\n            }\n        }\n        if (shouldRerender && !unmountedRef.current) {\n            rerender({});\n        }\n    }, // config.suspense isn't allowed to change during the lifecycle\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []);\n    // Always update the state reference.\n    useIsomorphicLayoutEffect(function() {\n        stateRef.current = state;\n    });\n    return [\n        stateRef,\n        stateDependenciesRef.current,\n        setState\n    ];\n};\nvar normalize = function(args) {\n    return isFunction(args[1]) ? [\n        args[0],\n        args[1],\n        args[2] || {}\n    ] : [\n        args[0],\n        null,\n        (args[1] === null ? args[2] : args[1]) || {}\n    ];\n};\nvar useSWRConfig = function() {\n    return mergeObjects(defaultConfig, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext));\n};\n// It's tricky to pass generic types as parameters, so we just directly override\n// the types here.\nvar withArgs = function(hook) {\n    return function useSWRArgs() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        // Get the default and inherited configuration.\n        var fallbackConfig = useSWRConfig();\n        // Normalize arguments.\n        var _a = normalize(args), key = _a[0], fn = _a[1], _config = _a[2];\n        // Merge configurations.\n        var config = mergeConfigs(fallbackConfig, _config);\n        // Apply middleware\n        var next = hook;\n        var use = config.use;\n        if (use) {\n            for(var i = use.length; i-- > 0;){\n                next = use[i](next);\n            }\n        }\n        return next(key, fn || config.fetcher, config);\n    };\n};\n// Add a callback function to a list of keyed callback functions and return\n// the unsubscribe function.\nvar subscribeCallback = function(key, callbacks, callback) {\n    var keyedRevalidators = callbacks[key] || (callbacks[key] = []);\n    keyedRevalidators.push(callback);\n    return function() {\n        var index = keyedRevalidators.indexOf(callback);\n        if (index >= 0) {\n            // O(1): faster than splice\n            keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];\n            keyedRevalidators.pop();\n        }\n    };\n};\nvar WITH_DEDUPE = {\n    dedupe: true\n};\nvar useSWRHandler = function(_key, fetcher, config) {\n    var cache = config.cache, compare = config.compare, fallbackData = config.fallbackData, suspense = config.suspense, revalidateOnMount = config.revalidateOnMount, refreshInterval = config.refreshInterval, refreshWhenHidden = config.refreshWhenHidden, refreshWhenOffline = config.refreshWhenOffline;\n    var _a = SWRGlobalState.get(cache), EVENT_REVALIDATORS = _a[0], STATE_UPDATERS = _a[1], MUTATION = _a[2], FETCH = _a[3];\n    // `key` is the identifier of the SWR `data` state, `keyInfo` holds extra\n    // states such as `error` and `isValidating` inside,\n    // all of them are derived from `_key`.\n    // `fnArgs` is an array of arguments parsed from the key, which will be passed\n    // to the fetcher.\n    var _b = serialize(_key), key = _b[0], fnArgs = _b[1], keyInfo = _b[2];\n    // If it's the initial render of this hook.\n    var initialMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // If the hook is unmounted already. This will be used to prevent some effects\n    // to be called after unmounting.\n    var unmountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Refs to keep the key and config.\n    var keyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(key);\n    var fetcherRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(fetcher);\n    var configRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(config);\n    var getConfig = function() {\n        return configRef.current;\n    };\n    var isActive = function() {\n        return getConfig().isVisible() && getConfig().isOnline();\n    };\n    var patchFetchInfo = function(info) {\n        return cache.set(keyInfo, mergeObjects(cache.get(keyInfo), info));\n    };\n    // Get the current state that SWR should return.\n    var cached = cache.get(key);\n    var fallback = isUndefined(fallbackData) ? config.fallback[key] : fallbackData;\n    var data = isUndefined(cached) ? fallback : cached;\n    var info = cache.get(keyInfo) || {};\n    var error = info.error;\n    var isInitialMount = !initialMountedRef.current;\n    // - Suspense mode and there's stale data for the initial render.\n    // - Not suspense mode and there is no fallback data and `revalidateIfStale` is enabled.\n    // - `revalidateIfStale` is enabled but `data` is not defined.\n    var shouldRevalidate = function() {\n        // If `revalidateOnMount` is set, we take the value directly.\n        if (isInitialMount && !isUndefined(revalidateOnMount)) return revalidateOnMount;\n        // If it's paused, we skip revalidation.\n        if (getConfig().isPaused()) return false;\n        // Under suspense mode, it will always fetch on render if there is no\n        // stale data so no need to revalidate immediately on mount again.\n        // If data exists, only revalidate if `revalidateIfStale` is true.\n        if (suspense) return isUndefined(data) ? false : config.revalidateIfStale;\n        // If there is no stale data, we need to revalidate on mount;\n        // If `revalidateIfStale` is set to true, we will always revalidate.\n        return isUndefined(data) || config.revalidateIfStale;\n    };\n    // Resolve the current validating state.\n    var resolveValidating = function() {\n        if (!key || !fetcher) return false;\n        if (info.isValidating) return true;\n        // If it's not mounted yet and it should revalidate on mount, revalidate.\n        return isInitialMount && shouldRevalidate();\n    };\n    var isValidating = resolveValidating();\n    var _c = useStateWithDeps({\n        data: data,\n        error: error,\n        isValidating: isValidating\n    }, unmountedRef), stateRef = _c[0], stateDependencies = _c[1], setState = _c[2];\n    // The revalidation function is a carefully crafted wrapper of the original\n    // `fetcher`, to correctly handle the many edge cases.\n    var revalidate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(revalidateOpts) {\n        return __awaiter(void 0, void 0, void 0, function() {\n            var currentFetcher, newData, startAt, loading, opts, shouldStartNewRequest, isCurrentKeyMounted, cleanupState, newState, finishRequestAndUpdateState, mutationInfo, err_1;\n            var _a;\n            return __generator(this, function(_b) {\n                switch(_b.label){\n                    case 0:\n                        currentFetcher = fetcherRef.current;\n                        if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused()) {\n                            return [\n                                2 /*return*/ ,\n                                false\n                            ];\n                        }\n                        loading = true;\n                        opts = revalidateOpts || {};\n                        shouldStartNewRequest = !FETCH[key] || !opts.dedupe;\n                        isCurrentKeyMounted = function() {\n                            return !unmountedRef.current && key === keyRef.current && initialMountedRef.current;\n                        };\n                        cleanupState = function() {\n                            // Check if it's still the same request before deleting.\n                            var requestInfo = FETCH[key];\n                            if (requestInfo && requestInfo[1] === startAt) {\n                                delete FETCH[key];\n                            }\n                        };\n                        newState = {\n                            isValidating: false\n                        };\n                        finishRequestAndUpdateState = function() {\n                            patchFetchInfo({\n                                isValidating: false\n                            });\n                            // We can only set state if it's safe (still mounted with the same key).\n                            if (isCurrentKeyMounted()) {\n                                setState(newState);\n                            }\n                        };\n                        // Start fetching. Change the `isValidating` state, update the cache.\n                        patchFetchInfo({\n                            isValidating: true\n                        });\n                        setState({\n                            isValidating: true\n                        });\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([\n                            1,\n                            3,\n                            ,\n                            4\n                        ]);\n                        if (shouldStartNewRequest) {\n                            // Tell all other hooks to change the `isValidating` state.\n                            broadcastState(cache, key, stateRef.current.data, stateRef.current.error, true);\n                            // If no cache being rendered currently (it shows a blank page),\n                            // we trigger the loading slow event.\n                            if (config.loadingTimeout && !cache.get(key)) {\n                                setTimeout(function() {\n                                    if (loading && isCurrentKeyMounted()) {\n                                        getConfig().onLoadingSlow(key, config);\n                                    }\n                                }, config.loadingTimeout);\n                            }\n                            // Start the request and save the timestamp.\n                            FETCH[key] = [\n                                currentFetcher.apply(void 0, fnArgs),\n                                getTimestamp()\n                            ];\n                        }\n                        _a = FETCH[key], newData = _a[0], startAt = _a[1];\n                        return [\n                            4 /*yield*/ ,\n                            newData\n                        ];\n                    case 2:\n                        newData = _b.sent();\n                        if (shouldStartNewRequest) {\n                            // If the request isn't interrupted, clean it up after the\n                            // deduplication interval.\n                            setTimeout(cleanupState, config.dedupingInterval);\n                        }\n                        // If there're other ongoing request(s), started after the current one,\n                        // we need to ignore the current one to avoid possible race conditions:\n                        //   req1------------------>res1        (current one)\n                        //        req2---------------->res2\n                        // the request that fired later will always be kept.\n                        // The timestamp maybe be `undefined` or a number\n                        if (!FETCH[key] || FETCH[key][1] !== startAt) {\n                            if (shouldStartNewRequest) {\n                                if (isCurrentKeyMounted()) {\n                                    getConfig().onDiscarded(key);\n                                }\n                            }\n                            return [\n                                2 /*return*/ ,\n                                false\n                            ];\n                        }\n                        // Clear error.\n                        patchFetchInfo({\n                            error: UNDEFINED\n                        });\n                        newState.error = UNDEFINED;\n                        mutationInfo = MUTATION[key];\n                        if (!isUndefined(mutationInfo) && // case 1\n                        (startAt <= mutationInfo[0] || // case 2\n                        startAt <= mutationInfo[1] || // case 3\n                        mutationInfo[1] === 0)) {\n                            finishRequestAndUpdateState();\n                            if (shouldStartNewRequest) {\n                                if (isCurrentKeyMounted()) {\n                                    getConfig().onDiscarded(key);\n                                }\n                            }\n                            return [\n                                2 /*return*/ ,\n                                false\n                            ];\n                        }\n                        // Deep compare with latest state to avoid extra re-renders.\n                        // For local state, compare and assign.\n                        if (!compare(stateRef.current.data, newData)) {\n                            newState.data = newData;\n                        } else {\n                            // data and newData are deeply equal\n                            // it should be safe to broadcast the stale data\n                            newState.data = stateRef.current.data;\n                        // At the end of this function, `brocastState` invokes the `onStateUpdate` function,\n                        // which takes care of avoiding the re-render\n                        }\n                        // For global state, it's possible that the key has changed.\n                        // https://github.com/vercel/swr/pull/1058\n                        if (!compare(cache.get(key), newData)) {\n                            cache.set(key, newData);\n                        }\n                        // Trigger the successful callback if it's the original request.\n                        if (shouldStartNewRequest) {\n                            if (isCurrentKeyMounted()) {\n                                getConfig().onSuccess(newData, key, config);\n                            }\n                        }\n                        return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                    case 3:\n                        err_1 = _b.sent();\n                        cleanupState();\n                        // Not paused, we continue handling the error. Otherwise discard it.\n                        if (!getConfig().isPaused()) {\n                            // Get a new error, don't use deep comparison for errors.\n                            patchFetchInfo({\n                                error: err_1\n                            });\n                            newState.error = err_1;\n                            // Error event and retry logic. Only for the actual request, not\n                            // deduped ones.\n                            if (shouldStartNewRequest && isCurrentKeyMounted()) {\n                                getConfig().onError(err_1, key, config);\n                                if (typeof config.shouldRetryOnError === \"boolean\" && config.shouldRetryOnError || isFunction(config.shouldRetryOnError) && config.shouldRetryOnError(err_1)) {\n                                    // When retrying, dedupe is always enabled\n                                    if (isActive()) {\n                                        // If it's active, stop. It will auto revalidate when refocusing\n                                        // or reconnecting.\n                                        getConfig().onErrorRetry(err_1, key, config, revalidate, {\n                                            retryCount: (opts.retryCount || 0) + 1,\n                                            dedupe: true\n                                        });\n                                    }\n                                }\n                            }\n                        }\n                        return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                    case 4:\n                        // Mark loading as stopped.\n                        loading = false;\n                        // Update the current hook's state.\n                        finishRequestAndUpdateState();\n                        // Here is the source of the request, need to tell all other hooks to\n                        // update their states.\n                        if (isCurrentKeyMounted() && shouldStartNewRequest) {\n                            broadcastState(cache, key, newState.data, newState.error, false);\n                        }\n                        return [\n                            2 /*return*/ ,\n                            true\n                        ];\n                }\n            });\n        });\n    }, // `setState` is immutable, and `eventsCallback`, `fnArgs`, `keyInfo`,\n    // and `keyValidating` are depending on `key`, so we can exclude them from\n    // the deps array.\n    //\n    // FIXME:\n    // `fn` and `config` might be changed during the lifecycle,\n    // but they might be changed every render like this.\n    // `useSWR('key', () => fetch('/api/'), { suspense: true })`\n    // So we omit the values from the deps array\n    // even though it might cause unexpected behaviors.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        key\n    ]);\n    // Similar to the global mutate, but bound to the current cache and key.\n    // `cache` isn't allowed to change during the lifecycle.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    var boundMutate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(// By using `bind` we don't need to modify the size of the rest arguments.\n    // Due to https://github.com/microsoft/TypeScript/issues/37181, we have to\n    // cast it to any for now.\n    internalMutate.bind(UNDEFINED, cache, function() {\n        return keyRef.current;\n    }), // eslint-disable-next-line react-hooks/exhaustive-deps\n    []);\n    // Always update fetcher and config refs.\n    useIsomorphicLayoutEffect(function() {\n        fetcherRef.current = fetcher;\n        configRef.current = config;\n    });\n    // After mounted or key changed.\n    useIsomorphicLayoutEffect(function() {\n        if (!key) return;\n        var keyChanged = key !== keyRef.current;\n        var softRevalidate = revalidate.bind(UNDEFINED, WITH_DEDUPE);\n        // Expose state updater to global event listeners. So we can update hook's\n        // internal state from the outside.\n        var onStateUpdate = function(updatedData, updatedError, updatedIsValidating) {\n            setState(mergeObjects({\n                error: updatedError,\n                isValidating: updatedIsValidating\n            }, // Since `setState` only shallowly compares states, we do a deep\n            // comparison here.\n            compare(stateRef.current.data, updatedData) ? UNDEFINED : {\n                data: updatedData\n            }));\n        };\n        // Expose revalidators to global event listeners. So we can trigger\n        // revalidation from the outside.\n        var nextFocusRevalidatedAt = 0;\n        var onRevalidate = function(type) {\n            if (type == FOCUS_EVENT) {\n                var now = Date.now();\n                if (getConfig().revalidateOnFocus && now > nextFocusRevalidatedAt && isActive()) {\n                    nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval;\n                    softRevalidate();\n                }\n            } else if (type == RECONNECT_EVENT) {\n                if (getConfig().revalidateOnReconnect && isActive()) {\n                    softRevalidate();\n                }\n            } else if (type == MUTATE_EVENT) {\n                return revalidate();\n            }\n            return;\n        };\n        var unsubUpdate = subscribeCallback(key, STATE_UPDATERS, onStateUpdate);\n        var unsubEvents = subscribeCallback(key, EVENT_REVALIDATORS, onRevalidate);\n        // Mark the component as mounted and update corresponding refs.\n        unmountedRef.current = false;\n        keyRef.current = key;\n        initialMountedRef.current = true;\n        // When `key` updates, reset the state to the initial value\n        // and trigger a rerender if necessary.\n        if (keyChanged) {\n            setState({\n                data: data,\n                error: error,\n                isValidating: isValidating\n            });\n        }\n        // Trigger a revalidation.\n        if (shouldRevalidate()) {\n            if (isUndefined(data) || IS_SERVER) {\n                // Revalidate immediately.\n                softRevalidate();\n            } else {\n                // Delay the revalidate if we have data to return so we won't block\n                // rendering.\n                rAF(softRevalidate);\n            }\n        }\n        return function() {\n            // Mark it as unmounted.\n            unmountedRef.current = true;\n            unsubUpdate();\n            unsubEvents();\n        };\n    }, [\n        key,\n        revalidate\n    ]);\n    // Polling\n    useIsomorphicLayoutEffect(function() {\n        var timer;\n        function next() {\n            // Use the passed interval\n            // ...or invoke the function with the updated data to get the interval\n            var interval = isFunction(refreshInterval) ? refreshInterval(data) : refreshInterval;\n            // We only start next interval if `refreshInterval` is not 0, and:\n            // - `force` is true, which is the start of polling\n            // - or `timer` is not 0, which means the effect wasn't canceled\n            if (interval && timer !== -1) {\n                timer = setTimeout(execute, interval);\n            }\n        }\n        function execute() {\n            // Check if it's OK to execute:\n            // Only revalidate when the page is visible, online and not errored.\n            if (!stateRef.current.error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline())) {\n                revalidate(WITH_DEDUPE).then(next);\n            } else {\n                // Schedule next interval to check again.\n                next();\n            }\n        }\n        next();\n        return function() {\n            if (timer) {\n                clearTimeout(timer);\n                timer = -1;\n            }\n        };\n    }, [\n        refreshInterval,\n        refreshWhenHidden,\n        refreshWhenOffline,\n        revalidate\n    ]);\n    // Display debug info in React DevTools.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(data);\n    // In Suspense mode, we can't return the empty `data` state.\n    // If there is `error`, the `error` needs to be thrown to the error boundary.\n    // If there is no `error`, the `revalidation` promise needs to be thrown to\n    // the suspense boundary.\n    if (suspense && isUndefined(data) && key) {\n        // Always update fetcher and config refs even with the Suspense mode.\n        fetcherRef.current = fetcher;\n        configRef.current = config;\n        unmountedRef.current = false;\n        throw isUndefined(error) ? revalidate(WITH_DEDUPE) : error;\n    }\n    return {\n        mutate: boundMutate,\n        get data () {\n            stateDependencies.data = true;\n            return data;\n        },\n        get error () {\n            stateDependencies.error = true;\n            return error;\n        },\n        get isValidating () {\n            stateDependencies.isValidating = true;\n            return isValidating;\n        }\n    };\n};\nvar SWRConfig = OBJECT.defineProperty(SWRConfig$1, \"default\", {\n    value: defaultConfig\n});\nvar unstable_serialize = function(key) {\n    return serialize(key)[0];\n};\nvar useSWR = withArgs(useSWRHandler);\n// useSWR\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3N3ci9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMkk7QUFFM0k7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBRTlFLFNBQVNTLFVBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDaEQsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUVBLFNBQVNPLFlBQVlsQixPQUFPLEVBQUVtQixJQUFJO0lBQzlCLElBQUlDLElBQUk7UUFBRUMsT0FBTztRQUFHQyxNQUFNO1lBQWEsSUFBSUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLE1BQU1BLENBQUMsQ0FBQyxFQUFFO1lBQUUsT0FBT0EsQ0FBQyxDQUFDLEVBQUU7UUFBRTtRQUFHQyxNQUFNLEVBQUU7UUFBRUMsS0FBSyxFQUFFO0lBQUMsR0FBR0MsR0FBR0MsR0FBR0osR0FBR0s7SUFDL0csT0FBT0EsSUFBSTtRQUFFakIsTUFBTWtCLEtBQUs7UUFBSSxTQUFTQSxLQUFLO1FBQUksVUFBVUEsS0FBSztJQUFHLEdBQUcsT0FBT0MsV0FBVyxjQUFlRixDQUFBQSxDQUFDLENBQUNFLE9BQU9DLFFBQVEsQ0FBQyxHQUFHO1FBQWEsT0FBTyxJQUFJO0lBQUUsSUFBSUg7SUFDdkosU0FBU0MsS0FBS0csQ0FBQztRQUFJLE9BQU8sU0FBVUMsQ0FBQztZQUFJLE9BQU92QixLQUFLO2dCQUFDc0I7Z0JBQUdDO2FBQUU7UUFBRztJQUFHO0lBQ2pFLFNBQVN2QixLQUFLd0IsRUFBRTtRQUNaLElBQUlSLEdBQUcsTUFBTSxJQUFJUyxVQUFVO1FBQzNCLE1BQU9mLEVBQUcsSUFBSTtZQUNWLElBQUlNLElBQUksR0FBR0MsS0FBTUosQ0FBQUEsSUFBSVcsRUFBRSxDQUFDLEVBQUUsR0FBRyxJQUFJUCxDQUFDLENBQUMsU0FBUyxHQUFHTyxFQUFFLENBQUMsRUFBRSxHQUFHUCxDQUFDLENBQUMsUUFBUSxJQUFLLEVBQUNKLElBQUlJLENBQUMsQ0FBQyxTQUFTLEtBQUtKLEVBQUVhLElBQUksQ0FBQ1QsSUFBSSxLQUFLQSxFQUFFaEIsSUFBSSxLQUFLLENBQUMsQ0FBQ1ksSUFBSUEsRUFBRWEsSUFBSSxDQUFDVCxHQUFHTyxFQUFFLENBQUMsRUFBRSxHQUFHbkIsSUFBSSxFQUFFLE9BQU9RO1lBQzNKLElBQUlJLElBQUksR0FBR0osR0FBR1csS0FBSztnQkFBQ0EsRUFBRSxDQUFDLEVBQUUsR0FBRztnQkFBR1gsRUFBRWxCLEtBQUs7YUFBQztZQUN2QyxPQUFRNkIsRUFBRSxDQUFDLEVBQUU7Z0JBQ1QsS0FBSztnQkFBRyxLQUFLO29CQUFHWCxJQUFJVztvQkFBSTtnQkFDeEIsS0FBSztvQkFBR2QsRUFBRUMsS0FBSztvQkFBSSxPQUFPO3dCQUFFaEIsT0FBTzZCLEVBQUUsQ0FBQyxFQUFFO3dCQUFFbkIsTUFBTTtvQkFBTTtnQkFDdEQsS0FBSztvQkFBR0ssRUFBRUMsS0FBSztvQkFBSU0sSUFBSU8sRUFBRSxDQUFDLEVBQUU7b0JBQUVBLEtBQUs7d0JBQUM7cUJBQUU7b0JBQUU7Z0JBQ3hDLEtBQUs7b0JBQUdBLEtBQUtkLEVBQUVLLEdBQUcsQ0FBQ1ksR0FBRztvQkFBSWpCLEVBQUVJLElBQUksQ0FBQ2EsR0FBRztvQkFBSTtnQkFDeEM7b0JBQ0ksSUFBSSxDQUFFZCxDQUFBQSxJQUFJSCxFQUFFSSxJQUFJLEVBQUVELElBQUlBLEVBQUVlLE1BQU0sR0FBRyxLQUFLZixDQUFDLENBQUNBLEVBQUVlLE1BQU0sR0FBRyxFQUFFLEtBQU1KLENBQUFBLEVBQUUsQ0FBQyxFQUFFLEtBQUssS0FBS0EsRUFBRSxDQUFDLEVBQUUsS0FBSyxJQUFJO3dCQUFFZCxJQUFJO3dCQUFHO29CQUFVO29CQUMzRyxJQUFJYyxFQUFFLENBQUMsRUFBRSxLQUFLLEtBQU0sRUFBQ1gsS0FBTVcsRUFBRSxDQUFDLEVBQUUsR0FBR1gsQ0FBQyxDQUFDLEVBQUUsSUFBSVcsRUFBRSxDQUFDLEVBQUUsR0FBR1gsQ0FBQyxDQUFDLEVBQUUsR0FBSTt3QkFBRUgsRUFBRUMsS0FBSyxHQUFHYSxFQUFFLENBQUMsRUFBRTt3QkFBRTtvQkFBTztvQkFDckYsSUFBSUEsRUFBRSxDQUFDLEVBQUUsS0FBSyxLQUFLZCxFQUFFQyxLQUFLLEdBQUdFLENBQUMsQ0FBQyxFQUFFLEVBQUU7d0JBQUVILEVBQUVDLEtBQUssR0FBR0UsQ0FBQyxDQUFDLEVBQUU7d0JBQUVBLElBQUlXO3dCQUFJO29CQUFPO29CQUNwRSxJQUFJWCxLQUFLSCxFQUFFQyxLQUFLLEdBQUdFLENBQUMsQ0FBQyxFQUFFLEVBQUU7d0JBQUVILEVBQUVDLEtBQUssR0FBR0UsQ0FBQyxDQUFDLEVBQUU7d0JBQUVILEVBQUVLLEdBQUcsQ0FBQ2MsSUFBSSxDQUFDTDt3QkFBSztvQkFBTztvQkFDbEUsSUFBSVgsQ0FBQyxDQUFDLEVBQUUsRUFBRUgsRUFBRUssR0FBRyxDQUFDWSxHQUFHO29CQUNuQmpCLEVBQUVJLElBQUksQ0FBQ2EsR0FBRztvQkFBSTtZQUN0QjtZQUNBSCxLQUFLZixLQUFLaUIsSUFBSSxDQUFDcEMsU0FBU29CO1FBQzVCLEVBQUUsT0FBT1IsR0FBRztZQUFFc0IsS0FBSztnQkFBQztnQkFBR3RCO2FBQUU7WUFBRWUsSUFBSTtRQUFHLFNBQVU7WUFBRUQsSUFBSUgsSUFBSTtRQUFHO1FBQ3pELElBQUlXLEVBQUUsQ0FBQyxFQUFFLEdBQUcsR0FBRyxNQUFNQSxFQUFFLENBQUMsRUFBRTtRQUFFLE9BQU87WUFBRTdCLE9BQU82QixFQUFFLENBQUMsRUFBRSxHQUFHQSxFQUFFLENBQUMsRUFBRSxHQUFHLEtBQUs7WUFBR25CLE1BQU07UUFBSztJQUNuRjtBQUNKO0FBRUEsSUFBSXlCLE9BQU8sWUFBYztBQUN6Qiw0RUFBNEU7QUFDNUUsK0VBQStFO0FBQy9FLDhEQUE4RDtBQUM5RCxrQkFBa0I7QUFDbEIsSUFBSUMsWUFBYyxlQUFlLEdBQUVEO0FBQ25DLElBQUlFLFNBQVNDO0FBQ2IsSUFBSUMsY0FBYyxTQUFVWCxDQUFDO0lBQUksT0FBT0EsTUFBTVE7QUFBVztBQUN6RCxJQUFJSSxhQUFhLFNBQVVaLENBQUM7SUFBSSxPQUFPLE9BQU9BLEtBQUs7QUFBWTtBQUMvRCxJQUFJYSxlQUFlLFNBQVVDLENBQUMsRUFBRUMsQ0FBQztJQUFJLE9BQU9OLE9BQU9PLE1BQU0sQ0FBQyxDQUFDLEdBQUdGLEdBQUdDO0FBQUk7QUFDckUsSUFBSUUsZ0JBQWdCO0FBQ3BCLDhGQUE4RjtBQUM5RixJQUFJQyxZQUFZO0lBQWMsT0FBTyxlQUFpQkQ7QUFBZTtBQUNyRSxJQUFJRSxjQUFjO0lBQWMsT0FBTyxPQUFPQyxZQUFZSDtBQUFlO0FBQ3pFLElBQUlJLDJCQUEyQjtJQUMzQixPQUFPSCxlQUFlLE9BQU9JLE1BQU0sQ0FBQyx3QkFBd0IsSUFBSUw7QUFDcEU7QUFFQSwrQ0FBK0M7QUFDL0MsMkNBQTJDO0FBQzNDLHlEQUF5RDtBQUN6RCw2QkFBNkI7QUFDN0IsSUFBSU0sUUFBUSxJQUFJQztBQUNoQixxQkFBcUI7QUFDckIsSUFBSUMsVUFBVTtBQUNkLDhDQUE4QztBQUM5Qyw0Q0FBNEM7QUFDNUMsa0NBQWtDO0FBQ2xDLGdDQUFnQztBQUNoQyw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLCtFQUErRTtBQUMvRSxZQUFZO0FBQ1osSUFBSUMsYUFBYSxTQUFVQyxHQUFHO0lBQzFCLElBQUlDLE9BQU8sT0FBT0Q7SUFDbEIsSUFBSUUsY0FBY0YsT0FBT0EsSUFBSUUsV0FBVztJQUN4QyxJQUFJQyxTQUFTRCxlQUFlRTtJQUM1QixJQUFJbEQ7SUFDSixJQUFJbUQ7SUFDSixJQUFJdkIsT0FBT2tCLFNBQVNBLE9BQU8sQ0FBQ0csVUFBVUQsZUFBZUksUUFBUTtRQUN6RCw0RUFBNEU7UUFDNUUsc0RBQXNEO1FBQ3REcEQsU0FBUzBDLE1BQU1XLEdBQUcsQ0FBQ1A7UUFDbkIsSUFBSTlDLFFBQ0EsT0FBT0E7UUFDWCw0RUFBNEU7UUFDNUUsZ0NBQWdDO1FBQ2hDLDJFQUEyRTtRQUMzRUEsU0FBUyxFQUFFNEMsVUFBVTtRQUNyQkYsTUFBTVksR0FBRyxDQUFDUixLQUFLOUM7UUFDZixJQUFJZ0QsZUFBZU8sT0FBTztZQUN0QixTQUFTO1lBQ1R2RCxTQUFTO1lBQ1QsSUFBS21ELFFBQVEsR0FBR0EsUUFBUUwsSUFBSXRCLE1BQU0sRUFBRTJCLFFBQVM7Z0JBQ3pDbkQsVUFBVTZDLFdBQVdDLEdBQUcsQ0FBQ0ssTUFBTSxJQUFJO1lBQ3ZDO1lBQ0FULE1BQU1ZLEdBQUcsQ0FBQ1IsS0FBSzlDO1FBQ25CO1FBQ0EsSUFBSWdELGVBQWVwQixRQUFRO1lBQ3ZCLHFCQUFxQjtZQUNyQjVCLFNBQVM7WUFDVCxJQUFJd0QsT0FBTzVCLE9BQU80QixJQUFJLENBQUNWLEtBQUtXLElBQUk7WUFDaEMsTUFBTyxDQUFDM0IsWUFBYXFCLFFBQVFLLEtBQUtqQyxHQUFHLElBQU07Z0JBQ3ZDLElBQUksQ0FBQ08sWUFBWWdCLEdBQUcsQ0FBQ0ssTUFBTSxHQUFHO29CQUMxQm5ELFVBQVVtRCxRQUFRLE1BQU1OLFdBQVdDLEdBQUcsQ0FBQ0ssTUFBTSxJQUFJO2dCQUNyRDtZQUNKO1lBQ0FULE1BQU1ZLEdBQUcsQ0FBQ1IsS0FBSzlDO1FBQ25CO0lBQ0osT0FDSztRQUNEQSxTQUFTaUQsU0FDSEgsSUFBSVksTUFBTSxLQUNWWCxRQUFRLFdBQ0pELElBQUlhLFFBQVEsS0FDWlosUUFBUSxXQUNKYSxLQUFLQyxTQUFTLENBQUNmLE9BQ2YsS0FBS0E7SUFDdkI7SUFDQSxPQUFPOUM7QUFDWDtBQUVBOzs7Ozs7Q0FNQyxHQUNELElBQUk4RCxTQUFTO0FBQ2IsSUFBSUMsV0FBVztJQUFjLE9BQU9EO0FBQVE7QUFDNUMsSUFBSUUsU0FBUzNCO0FBQ2IsSUFBSTRCLFNBQVMzQjtBQUNiLGdGQUFnRjtBQUNoRixJQUFJNEIsZ0JBQWdCRixVQUFVdkIsT0FBTzBCLGdCQUFnQixHQUMvQzFCLE9BQU8wQixnQkFBZ0IsQ0FBQ0MsSUFBSSxDQUFDM0IsVUFDN0JmO0FBQ04sSUFBSTJDLGtCQUFrQkosU0FBUzFCLFNBQVM0QixnQkFBZ0IsQ0FBQ0MsSUFBSSxDQUFDN0IsWUFBWWI7QUFDMUUsSUFBSTRDLGlCQUFpQk4sVUFBVXZCLE9BQU84QixtQkFBbUIsR0FDbkQ5QixPQUFPOEIsbUJBQW1CLENBQUNILElBQUksQ0FBQzNCLFVBQ2hDZjtBQUNOLElBQUk4QyxtQkFBbUJQLFNBQ2pCMUIsU0FBU2dDLG1CQUFtQixDQUFDSCxJQUFJLENBQUM3QixZQUNsQ2I7QUFDTixJQUFJK0MsWUFBWTtJQUNaLElBQUlDLGtCQUFrQlQsVUFBVTFCLFNBQVNtQyxlQUFlO0lBQ3hELE9BQU81QyxZQUFZNEMsb0JBQW9CQSxvQkFBb0I7QUFDL0Q7QUFDQSxJQUFJQyxZQUFZLFNBQVVDLFFBQVE7SUFDOUIsbUJBQW1CO0lBQ25CUCxnQkFBZ0Isb0JBQW9CTztJQUNwQ1YsY0FBYyxTQUFTVTtJQUN2QixPQUFPO1FBQ0hKLGlCQUFpQixvQkFBb0JJO1FBQ3JDTixlQUFlLFNBQVNNO0lBQzVCO0FBQ0o7QUFDQSxJQUFJQyxnQkFBZ0IsU0FBVUQsUUFBUTtJQUNsQyw0QkFBNEI7SUFDNUIsSUFBSUUsV0FBVztRQUNYaEIsU0FBUztRQUNUYztJQUNKO0lBQ0EsZ0RBQWdEO0lBQ2hELElBQUlHLFlBQVk7UUFDWmpCLFNBQVM7SUFDYjtJQUNBSSxjQUFjLFVBQVVZO0lBQ3hCWixjQUFjLFdBQVdhO0lBQ3pCLE9BQU87UUFDSFQsZUFBZSxVQUFVUTtRQUN6QlIsZUFBZSxXQUFXUztJQUM5QjtBQUNKO0FBQ0EsSUFBSUMsU0FBUztJQUNUakIsVUFBVUE7SUFDVlUsV0FBV0E7QUFDZjtBQUNBLElBQUlRLHVCQUF1QjtJQUN2Qk4sV0FBV0E7SUFDWEUsZUFBZUE7QUFDbkI7QUFFQSxJQUFJSyxZQUFZLENBQUM3QyxlQUFlLFVBQVVJO0FBQzFDLGlDQUFpQztBQUNqQyxJQUFJMEMsTUFBTSxTQUFVdkUsQ0FBQztJQUNqQixPQUFPNEIsNkJBQTZCQyxNQUFNLENBQUMsd0JBQXdCLENBQUM3QixLQUFLd0UsV0FBV3hFLEdBQUc7QUFDM0Y7QUFDQSw2RUFBNkU7QUFDN0UsNkVBQTZFO0FBQzdFLGtDQUFrQztBQUNsQyxJQUFJeUUsNEJBQTRCSCxZQUFZMUcsNENBQVNBLEdBQUdDLGtEQUFlQTtBQUN2RSx3RUFBd0U7QUFDeEUsSUFBSTZHLHNCQUFzQixPQUFPQyxjQUFjLGVBQzNDQSxVQUFVQyxVQUFVO0FBQ3hCLGlFQUFpRTtBQUNqRSxJQUFJQyxpQkFBaUIsQ0FBQ1AsYUFDbEJJLHVCQUNDO0lBQUM7SUFBVztDQUFLLENBQUNJLFFBQVEsQ0FBQ0osb0JBQW9CSyxhQUFhLEtBQ3pETCxvQkFBb0JNLFFBQVE7QUFFcEMsSUFBSUMsWUFBWSxTQUFVQyxHQUFHO0lBQ3pCLElBQUkvRCxXQUFXK0QsTUFBTTtRQUNqQixJQUFJO1lBQ0FBLE1BQU1BO1FBQ1YsRUFDQSxPQUFPQyxLQUFLO1lBQ1IseUJBQXlCO1lBQ3pCRCxNQUFNO1FBQ1Y7SUFDSjtJQUNBLElBQUlFLE9BQU8sRUFBRSxDQUFDQyxNQUFNLENBQUNIO0lBQ3JCLHVEQUF1RDtJQUN2REEsTUFDSSxPQUFPQSxPQUFPLFdBQ1JBLE1BQ0EsQ0FBQ3ZDLE1BQU0yQyxPQUFPLENBQUNKLE9BQU9BLElBQUl0RSxNQUFNLEdBQUdzRSxHQUFFLElBQ2pDakQsV0FBV2lELE9BQ1g7SUFDZCxJQUFJSyxVQUFVTCxNQUFNLFVBQVVBLE1BQU07SUFDcEMsT0FBTztRQUFDQTtRQUFLRTtRQUFNRztLQUFRO0FBQy9CO0FBRUEsZ0VBQWdFO0FBQ2hFLElBQUlDLGlCQUFpQixJQUFJekQ7QUFFekIsSUFBSTBELGNBQWM7QUFDbEIsSUFBSUMsa0JBQWtCO0FBQ3RCLElBQUlDLGVBQWU7QUFFbkIsSUFBSUMsaUJBQWlCLFNBQVVDLEtBQUssRUFBRVgsR0FBRyxFQUFFWSxJQUFJLEVBQUVDLEtBQUssRUFBRUMsWUFBWSxFQUFFQyxVQUFVLEVBQUVDLFNBQVM7SUFDdkYsSUFBSUEsY0FBYyxLQUFLLEdBQUc7UUFBRUEsWUFBWTtJQUFNO0lBQzlDLElBQUlDLEtBQUtYLGVBQWUvQyxHQUFHLENBQUNvRCxRQUFRTyxxQkFBcUJELEVBQUUsQ0FBQyxFQUFFLEVBQUVFLGlCQUFpQkYsRUFBRSxDQUFDLEVBQUUsRUFBRUcsUUFBUUgsRUFBRSxDQUFDLEVBQUU7SUFDckcsSUFBSUksZUFBZUgsa0JBQWtCLENBQUNsQixJQUFJO0lBQzFDLElBQUlzQixXQUFXSCxjQUFjLENBQUNuQixJQUFJO0lBQ2xDLG1EQUFtRDtJQUNuRCxJQUFJZ0IsYUFBYU0sVUFBVTtRQUN2QixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUQsU0FBUzVGLE1BQU0sRUFBRSxFQUFFNkYsRUFBRztZQUN0Q0QsUUFBUSxDQUFDQyxFQUFFLENBQUNYLE1BQU1DLE9BQU9DO1FBQzdCO0lBQ0o7SUFDQSxnRUFBZ0U7SUFDaEUsSUFBSUMsWUFBWTtRQUNaLHVFQUF1RTtRQUN2RSxnQ0FBZ0M7UUFDaEMsT0FBT0ssS0FBSyxDQUFDcEIsSUFBSTtRQUNqQixJQUFJcUIsZ0JBQWdCQSxZQUFZLENBQUMsRUFBRSxFQUFFO1lBQ2pDLE9BQU9BLFlBQVksQ0FBQyxFQUFFLENBQUNaLGNBQWNyRyxJQUFJLENBQUM7Z0JBQ3RDLE9BQU91RyxNQUFNcEQsR0FBRyxDQUFDeUM7WUFDckI7UUFDSjtJQUNKO0lBQ0EsT0FBT1csTUFBTXBELEdBQUcsQ0FBQ3lDO0FBQ3JCO0FBRUEsb0JBQW9CO0FBQ3BCLElBQUl3QixjQUFjO0FBQ2xCLElBQUlDLGVBQWU7SUFBYyxPQUFPLEVBQUVEO0FBQWE7QUFFdkQsSUFBSUUsaUJBQWlCO0lBQ2pCLElBQUl4QixPQUFPLEVBQUU7SUFDYixJQUFLLElBQUl5QixLQUFLLEdBQUdBLEtBQUtDLFVBQVVsRyxNQUFNLEVBQUVpRyxLQUFNO1FBQzFDekIsSUFBSSxDQUFDeUIsR0FBRyxHQUFHQyxTQUFTLENBQUNELEdBQUc7SUFDNUI7SUFDQSxPQUFPeEksVUFBVSxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssR0FBRztRQUNyQyxJQUFJd0gsT0FBT2tCLE1BQU1DLE9BQU9DLE9BQU9DLFNBQVNDLGVBQWVsQixZQUFZbUIsaUJBQWlCQyxzQkFBc0JsQixJQUFJakIsS0FBS29DLFNBQVNDLElBQUlDLFVBQVUxQixNQUFNQyxPQUFPMEIsa0JBQWtCQyx5QkFBeUJDLGNBQWNDLGdCQUFnQkM7UUFDaE8sT0FBT3JJLFlBQVksSUFBSSxFQUFFLFNBQVVzSSxFQUFFO1lBQ2pDLE9BQVFBLEdBQUduSSxLQUFLO2dCQUNaLEtBQUs7b0JBQ0RrRyxRQUFRVCxJQUFJLENBQUMsRUFBRSxFQUFFMkIsT0FBTzNCLElBQUksQ0FBQyxFQUFFLEVBQUU0QixRQUFRNUIsSUFBSSxDQUFDLEVBQUUsRUFBRTZCLFFBQVE3QixJQUFJLENBQUMsRUFBRTtvQkFDakU4QixVQUFVLE9BQU9ELFVBQVUsWUFBWTt3QkFBRWhCLFlBQVlnQjtvQkFBTSxJQUFJQSxTQUFTLENBQUM7b0JBQ3pFRSxnQkFBZ0JqRyxZQUFZZ0csUUFBUUMsYUFBYSxJQUMzQyxPQUNBRCxRQUFRQyxhQUFhO29CQUMzQmxCLGFBQWFpQixRQUFRakIsVUFBVSxLQUFLO29CQUNwQ21CLGtCQUFrQkYsUUFBUUUsZUFBZSxLQUFLO29CQUM5Q0MsdUJBQXVCSCxRQUFRVSxjQUFjO29CQUM3Q3pCLEtBQUtsQixVQUFVOEIsT0FBTzdCLE1BQU1pQixFQUFFLENBQUMsRUFBRSxFQUFFbUIsVUFBVW5CLEVBQUUsQ0FBQyxFQUFFO29CQUNsRCxJQUFJLENBQUNqQixLQUNELE9BQU87d0JBQUMsRUFBRSxRQUFRO3FCQUFHO29CQUN6QnFDLEtBQUsvQixlQUFlL0MsR0FBRyxDQUFDb0QsUUFBUTJCLFdBQVdELEVBQUUsQ0FBQyxFQUFFO29CQUNoRCwyRUFBMkU7b0JBQzNFLElBQUluQyxLQUFLeEUsTUFBTSxHQUFHLEdBQUc7d0JBQ2pCLGtDQUFrQzt3QkFDbEMsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUlnRixlQUFlQyxPQUFPWCxLQUFLVyxNQUFNcEQsR0FBRyxDQUFDeUMsTUFBTW5FLFdBQVdBLFdBQVdrRixZQUFZO3lCQUFNO29CQUM3RztvQkFDQUgsT0FBT2tCO29CQUNQUyxtQkFBbUJkO29CQUNuQmEsUUFBUSxDQUFDdEMsSUFBSSxHQUFHO3dCQUFDdUM7d0JBQWtCO3FCQUFFO29CQUNyQ0MsMEJBQTBCLENBQUN4RyxZQUFZbUc7b0JBQ3ZDTSxlQUFlOUIsTUFBTXBELEdBQUcsQ0FBQ3lDO29CQUN6Qiw2QkFBNkI7b0JBQzdCLElBQUl3Qyx5QkFBeUI7d0JBQ3pCRSxpQkFBaUJ6RyxXQUFXa0csd0JBQ3RCQSxxQkFBcUJNLGdCQUNyQk47d0JBQ054QixNQUFNbkQsR0FBRyxDQUFDd0MsS0FBSzBDO3dCQUNmaEMsZUFBZUMsT0FBT1gsS0FBSzBDO29CQUMvQjtvQkFDQSxJQUFJekcsV0FBVzJFLE9BQU87d0JBQ2xCLDZEQUE2RDt3QkFDN0QsSUFBSTs0QkFDQUEsT0FBT0EsS0FBS0QsTUFBTXBELEdBQUcsQ0FBQ3lDO3dCQUMxQixFQUNBLE9BQU9DLEtBQUs7NEJBQ1Isc0VBQXNFOzRCQUN0RVksUUFBUVo7d0JBQ1o7b0JBQ0o7b0JBQ0EsSUFBSSxDQUFFVyxDQUFBQSxRQUFRM0UsV0FBVzJFLEtBQUt4RyxJQUFJLElBQUksT0FBTzt3QkFBQyxFQUFFLE9BQU87d0JBQUk7cUJBQUU7b0JBQzdELE9BQU87d0JBQUMsRUFBRSxPQUFPO3dCQUFJd0csS0FBS2lDLEtBQUssQ0FBQyxTQUFVNUMsR0FBRzs0QkFDckNZLFFBQVFaO3dCQUNaO3FCQUlIO2dCQUNMLEtBQUs7b0JBQ0Qsd0VBQXdFO29CQUN4RSx5QkFBeUI7b0JBQ3pCVyxPQUFPZ0MsR0FBR2xJLElBQUk7b0JBQ2QsNEVBQTRFO29CQUM1RSxtRUFBbUU7b0JBQ25FLHdCQUF3QjtvQkFDeEIsSUFBSTZILHFCQUFxQkQsUUFBUSxDQUFDdEMsSUFBSSxDQUFDLEVBQUUsRUFBRTt3QkFDdkMsSUFBSWEsT0FDQSxNQUFNQTt3QkFDVixPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSUQ7eUJBQUs7b0JBQy9CLE9BQ0ssSUFBSUMsU0FBUzJCLDJCQUEyQk4saUJBQWlCO3dCQUMxRCwrREFBK0Q7d0JBQy9ELHlCQUF5Qjt3QkFDekJELGdCQUFnQjt3QkFDaEJyQixPQUFPNkI7d0JBQ1A5QixNQUFNbkQsR0FBRyxDQUFDd0MsS0FBS3lDO29CQUNuQjtvQkFDQUcsR0FBR25JLEtBQUssR0FBRztnQkFDZixLQUFLO29CQUNELG1EQUFtRDtvQkFDbkQsSUFBSXdILGVBQWU7d0JBQ2YsSUFBSSxDQUFDcEIsT0FBTzs0QkFDUixrQ0FBa0M7NEJBQ2xDLElBQUk1RSxXQUFXZ0csZ0JBQWdCO2dDQUMzQnJCLE9BQU9xQixjQUFjckIsTUFBTTZCOzRCQUMvQjs0QkFDQSw2RUFBNkU7NEJBQzdFOUIsTUFBTW5ELEdBQUcsQ0FBQ3dDLEtBQUtZO3dCQUNuQjt3QkFDQSxvQ0FBb0M7d0JBQ3BDRCxNQUFNbkQsR0FBRyxDQUFDNEUsU0FBU2xHLGFBQWF5RSxNQUFNcEQsR0FBRyxDQUFDNkUsVUFBVTs0QkFBRXZCLE9BQU9BO3dCQUFNO29CQUN2RTtvQkFDQSxzREFBc0Q7b0JBQ3REeUIsUUFBUSxDQUFDdEMsSUFBSSxDQUFDLEVBQUUsR0FBR3lCO29CQUNuQixPQUFPO3dCQUFDLEVBQUUsT0FBTzt3QkFBSWYsZUFBZUMsT0FBT1gsS0FBS1ksTUFBTUMsT0FBT2hGLFdBQVdrRixZQUFZLENBQUMsQ0FBQ2tCO3FCQUVyRjtnQkFDTCxLQUFLO29CQUNEVSxNQUFNQyxHQUFHbEksSUFBSTtvQkFDYiw2QkFBNkI7b0JBQzdCLElBQUltRyxPQUNBLE1BQU1BO29CQUNWLE9BQU87d0JBQUMsRUFBRSxRQUFRO3dCQUFJb0IsZ0JBQWdCVSxNQUFNL0I7cUJBQUs7WUFDekQ7UUFDSjtJQUNKO0FBQ0o7QUFFQSxJQUFJa0Msb0JBQW9CLFNBQVV6QixZQUFZLEVBQUVwRSxJQUFJO0lBQ2hELElBQUssSUFBSStDLE9BQU9xQixhQUFjO1FBQzFCLElBQUlBLFlBQVksQ0FBQ3JCLElBQUksQ0FBQyxFQUFFLEVBQ3BCcUIsWUFBWSxDQUFDckIsSUFBSSxDQUFDLEVBQUUsQ0FBQy9DO0lBQzdCO0FBQ0o7QUFDQSxJQUFJOEYsWUFBWSxTQUFVQyxRQUFRLEVBQUVoQixPQUFPO0lBQ3ZDLHVFQUF1RTtJQUN2RSwyRUFBMkU7SUFDM0UsYUFBYTtJQUNiLDZFQUE2RTtJQUM3RSxtREFBbUQ7SUFDbkQsSUFBSSxDQUFDMUIsZUFBZTJDLEdBQUcsQ0FBQ0QsV0FBVztRQUMvQixJQUFJRSxPQUFPaEgsYUFBYWlELHNCQUFzQjZDO1FBQzlDLDhFQUE4RTtRQUM5RSx1QkFBdUI7UUFDdkIsSUFBSWQscUJBQXFCLENBQUM7UUFDMUIsSUFBSWlDLFNBQVN6QixlQUFlcEQsSUFBSSxDQUFDekMsV0FBV21IO1FBQzVDLElBQUlJLFVBQVV4SDtRQUNkLG1FQUFtRTtRQUNuRTBFLGVBQWU5QyxHQUFHLENBQUN3RixVQUFVO1lBQUM5QjtZQUFvQixDQUFDO1lBQUcsQ0FBQztZQUFHLENBQUM7WUFBR2lDO1NBQU87UUFDckUsd0VBQXdFO1FBQ3hFLGlEQUFpRDtRQUNqRCxJQUFJLENBQUMvRCxXQUFXO1lBQ1osOERBQThEO1lBQzlELHVFQUF1RTtZQUN2RSxxRUFBcUU7WUFDckUseUJBQXlCO1lBQ3pCLHFEQUFxRDtZQUNyRCw2Q0FBNkM7WUFDN0MsSUFBSWlFLGlCQUFpQkgsS0FBS3JFLFNBQVMsQ0FBQ1MsV0FBV2hCLElBQUksQ0FBQ3pDLFdBQVdpSCxrQkFBa0J4RSxJQUFJLENBQUN6QyxXQUFXcUYsb0JBQW9CWDtZQUNySCxJQUFJK0MscUJBQXFCSixLQUFLbkUsYUFBYSxDQUFDTyxXQUFXaEIsSUFBSSxDQUFDekMsV0FBV2lILGtCQUFrQnhFLElBQUksQ0FBQ3pDLFdBQVdxRixvQkFBb0JWO1lBQzdINEMsVUFBVTtnQkFDTkMsa0JBQWtCQTtnQkFDbEJDLHNCQUFzQkE7Z0JBQ3RCLHdFQUF3RTtnQkFDeEUsd0VBQXdFO2dCQUN4RSw4Q0FBOEM7Z0JBQzlDaEQsZUFBZWlELE1BQU0sQ0FBQ1A7WUFDMUI7UUFDSjtRQUNBLDZFQUE2RTtRQUM3RSwyQ0FBMkM7UUFDM0Msa0VBQWtFO1FBQ2xFLE9BQU87WUFBQ0E7WUFBVUc7WUFBUUM7U0FBUTtJQUN0QztJQUNBLE9BQU87UUFBQ0o7UUFBVTFDLGVBQWUvQyxHQUFHLENBQUN5RixTQUFTLENBQUMsRUFBRTtLQUFDO0FBQ3REO0FBRUEsY0FBYztBQUNkLElBQUlRLGVBQWUsU0FBVWhKLENBQUMsRUFBRWlKLEVBQUUsRUFBRUMsTUFBTSxFQUFFM0MsVUFBVSxFQUFFbUMsSUFBSTtJQUN4RCxJQUFJUyxnQkFBZ0JELE9BQU9FLGVBQWU7SUFDMUMsSUFBSUMsb0JBQW9CWCxLQUFLWSxVQUFVO0lBQ3ZDLHNCQUFzQjtJQUN0QixJQUFJQyxVQUFVLENBQUMsQ0FBRSxFQUFDQyxLQUFLQyxNQUFNLEtBQUssR0FBRSxJQUMvQixNQUFNSixDQUFBQSxvQkFBb0IsSUFBSUEsb0JBQW9CLEVBQUMsQ0FBQyxJQUFLSCxPQUFPUSxrQkFBa0I7SUFDdkYsSUFBSSxDQUFDbEksWUFBWTJILGtCQUFrQkUsb0JBQW9CRixlQUFlO1FBQ2xFO0lBQ0o7SUFDQXJFLFdBQVd5QixZQUFZZ0QsU0FBU2I7QUFDcEM7QUFDQSx5QkFBeUI7QUFDekIsSUFBSWpDLEtBQUs4QixVQUFVLElBQUlvQixRQUFReEQsUUFBUU0sRUFBRSxDQUFDLEVBQUUsRUFBRWtDLFNBQVNsQyxFQUFFLENBQUMsRUFBRTtBQUM1RCxpQkFBaUI7QUFDakIsSUFBSW1ELGdCQUFnQmxJLGFBQWE7SUFDN0IsU0FBUztJQUNUbUksZUFBZXpJO0lBQ2YwSSxXQUFXMUk7SUFDWDJJLFNBQVMzSTtJQUNUNEgsY0FBY0E7SUFDZGdCLGFBQWE1STtJQUNiLFdBQVc7SUFDWDZJLG1CQUFtQjtJQUNuQkMsdUJBQXVCO0lBQ3ZCQyxtQkFBbUI7SUFDbkJDLG9CQUFvQjtJQUNwQixXQUFXO0lBQ1hWLG9CQUFvQnZFLGlCQUFpQixRQUFRO0lBQzdDa0YsdUJBQXVCLElBQUk7SUFDM0JDLGtCQUFrQixJQUFJO0lBQ3RCQyxnQkFBZ0JwRixpQkFBaUIsT0FBTztJQUN4QyxZQUFZO0lBQ1pxRixTQUFTLFNBQVVDLFdBQVcsRUFBRUMsT0FBTztRQUNuQyxPQUFPbkksV0FBV2tJLGdCQUFnQmxJLFdBQVdtSTtJQUNqRDtJQUNBQyxVQUFVO1FBQWMsT0FBTztJQUFPO0lBQ3RDeEUsT0FBT0E7SUFDUHdDLFFBQVFBO0lBQ1JpQyxVQUFVLENBQUM7QUFDZixHQUNBLDRCQUE0QjtBQUM1QmxHO0FBRUEsSUFBSW1HLGVBQWUsU0FBVWxKLENBQUMsRUFBRUMsQ0FBQztJQUM3QixtRUFBbUU7SUFDbkUsSUFBSWYsSUFBSWEsYUFBYUMsR0FBR0M7SUFDeEIseUVBQXlFO0lBQ3pFLElBQUlBLEdBQUc7UUFDSCxJQUFJa0osS0FBS25KLEVBQUVvSixHQUFHLEVBQUVDLEtBQUtySixFQUFFaUosUUFBUTtRQUMvQixJQUFJSyxLQUFLckosRUFBRW1KLEdBQUcsRUFBRUcsS0FBS3RKLEVBQUVnSixRQUFRO1FBQy9CLElBQUlFLE1BQU1HLElBQUk7WUFDVnBLLEVBQUVrSyxHQUFHLEdBQUdELEdBQUduRixNQUFNLENBQUNzRjtRQUN0QjtRQUNBLElBQUlELE1BQU1FLElBQUk7WUFDVnJLLEVBQUUrSixRQUFRLEdBQUdsSixhQUFhc0osSUFBSUU7UUFDbEM7SUFDSjtJQUNBLE9BQU9ySztBQUNYO0FBRUEsSUFBSXNLLGlDQUFtQi9NLG9EQUFhQSxDQUFDLENBQUM7QUFDdEMsSUFBSWdOLGNBQWMsU0FBVUMsS0FBSztJQUM3QixJQUFJcE0sUUFBUW9NLE1BQU1wTSxLQUFLO0lBQ3ZCLCtDQUErQztJQUMvQyxJQUFJcU0saUJBQWlCVCxhQUFheE0saURBQVVBLENBQUM4TSxtQkFBbUJsTTtJQUNoRSx5Q0FBeUM7SUFDekMsSUFBSXVKLFdBQVd2SixTQUFTQSxNQUFNdUosUUFBUTtJQUN0QyxvRUFBb0U7SUFDcEUsSUFBSStDLGVBQWVqTiwrQ0FBUUEsQ0FBQztRQUN4QixPQUFPa0ssV0FDREQsVUFBVUMsU0FBUzhDLGVBQWVuRixLQUFLLElBQUlBLFFBQVFsSCxTQUNuRG9DO0lBQ1YsRUFBRSxDQUFDLEVBQUU7SUFDTCxpREFBaUQ7SUFDakQsSUFBSWtLLGNBQWM7UUFDZEQsZUFBZW5GLEtBQUssR0FBR29GLFlBQVksQ0FBQyxFQUFFO1FBQ3RDRCxlQUFlM0MsTUFBTSxHQUFHNEMsWUFBWSxDQUFDLEVBQUU7SUFDM0M7SUFDQSxzQkFBc0I7SUFDdEJ4RywwQkFBMEI7UUFBYyxPQUFRd0csZUFBZUEsWUFBWSxDQUFDLEVBQUUsR0FBR2xLO0lBQVksR0FBRyxFQUFFO0lBQ2xHLHFCQUFPOUMsb0RBQWFBLENBQUM0TSxpQkFBaUJLLFFBQVEsRUFBRTlKLGFBQWEySixPQUFPO1FBQ2hFcE0sT0FBT3FNO0lBQ1g7QUFDSjtBQUVBOztDQUVDLEdBQ0QsSUFBSUcsbUJBQW1CLFNBQVVDLEtBQUssRUFBRUMsWUFBWTtJQUNoRCxJQUFJQyxXQUFXdE4sK0NBQVFBLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRTtJQUM5QixJQUFJdU4sV0FBV3JOLDZDQUFNQSxDQUFDa047SUFDdEIsOEVBQThFO0lBQzlFLDJFQUEyRTtJQUMzRSx3Q0FBd0M7SUFDeEMsNkNBQTZDO0lBQzdDLElBQUlJLHVCQUF1QnROLDZDQUFNQSxDQUFDO1FBQzlCNEgsTUFBTTtRQUNOQyxPQUFPO1FBQ1BDLGNBQWM7SUFDbEI7SUFDQTs7Ozs7Ozs7Ozs7Ozs7OztLQWdCQyxHQUNELElBQUl5RixXQUFXdE4sa0RBQVdBLENBQUMsU0FBVXVOLE9BQU87UUFDeEMsSUFBSUMsaUJBQWlCO1FBQ3JCLElBQUlDLGVBQWVMLFNBQVNNLE9BQU87UUFDbkMsSUFBSyxJQUFJbk0sS0FBS2dNLFFBQVM7WUFDbkIsSUFBSUksSUFBSXBNO1lBQ1IscUVBQXFFO1lBQ3JFLFVBQVU7WUFDVixJQUFJa00sWUFBWSxDQUFDRSxFQUFFLEtBQUtKLE9BQU8sQ0FBQ0ksRUFBRSxFQUFFO2dCQUNoQ0YsWUFBWSxDQUFDRSxFQUFFLEdBQUdKLE9BQU8sQ0FBQ0ksRUFBRTtnQkFDNUIscUVBQXFFO2dCQUNyRSxhQUFhO2dCQUNiLElBQUlOLHFCQUFxQkssT0FBTyxDQUFDQyxFQUFFLEVBQUU7b0JBQ2pDSCxpQkFBaUI7Z0JBQ3JCO1lBQ0o7UUFDSjtRQUNBLElBQUlBLGtCQUFrQixDQUFDTixhQUFhUSxPQUFPLEVBQUU7WUFDekNQLFNBQVMsQ0FBQztRQUNkO0lBQ0osR0FDQSwrREFBK0Q7SUFDL0QsdURBQXVEO0lBQ3ZELEVBQUU7SUFDRixxQ0FBcUM7SUFDckM3RywwQkFBMEI7UUFDdEI4RyxTQUFTTSxPQUFPLEdBQUdUO0lBQ3ZCO0lBQ0EsT0FBTztRQUFDRztRQUFVQyxxQkFBcUJLLE9BQU87UUFBRUo7S0FBUztBQUM3RDtBQUVBLElBQUlNLFlBQVksU0FBVTNHLElBQUk7SUFDMUIsT0FBT2pFLFdBQVdpRSxJQUFJLENBQUMsRUFBRSxJQUNuQjtRQUFDQSxJQUFJLENBQUMsRUFBRTtRQUFFQSxJQUFJLENBQUMsRUFBRTtRQUFFQSxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUM7S0FBRSxHQUNqQztRQUFDQSxJQUFJLENBQUMsRUFBRTtRQUFFO1FBQU9BLENBQUFBLElBQUksQ0FBQyxFQUFFLEtBQUssT0FBT0EsSUFBSSxDQUFDLEVBQUUsR0FBR0EsSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDO0tBQUU7QUFDdkU7QUFFQSxJQUFJNEcsZUFBZTtJQUNmLE9BQU81SyxhQUFha0ksZUFBZXZMLGlEQUFVQSxDQUFDOE07QUFDbEQ7QUFFQSxnRkFBZ0Y7QUFDaEYsa0JBQWtCO0FBQ2xCLElBQUlvQixXQUFXLFNBQVVDLElBQUk7SUFDekIsT0FBTyxTQUFTQztRQUNaLElBQUkvRyxPQUFPLEVBQUU7UUFDYixJQUFLLElBQUl5QixLQUFLLEdBQUdBLEtBQUtDLFVBQVVsRyxNQUFNLEVBQUVpRyxLQUFNO1lBQzFDekIsSUFBSSxDQUFDeUIsR0FBRyxHQUFHQyxTQUFTLENBQUNELEdBQUc7UUFDNUI7UUFDQSwrQ0FBK0M7UUFDL0MsSUFBSXVGLGlCQUFpQko7UUFDckIsdUJBQXVCO1FBQ3ZCLElBQUk3RixLQUFLNEYsVUFBVTNHLE9BQU9GLE1BQU1pQixFQUFFLENBQUMsRUFBRSxFQUFFa0csS0FBS2xHLEVBQUUsQ0FBQyxFQUFFLEVBQUVtRyxVQUFVbkcsRUFBRSxDQUFDLEVBQUU7UUFDbEUsd0JBQXdCO1FBQ3hCLElBQUl5QyxTQUFTMkIsYUFBYTZCLGdCQUFnQkU7UUFDMUMsbUJBQW1CO1FBQ25CLElBQUlyTixPQUFPaU47UUFDWCxJQUFJekIsTUFBTTdCLE9BQU82QixHQUFHO1FBQ3BCLElBQUlBLEtBQUs7WUFDTCxJQUFLLElBQUloRSxJQUFJZ0UsSUFBSTdKLE1BQU0sRUFBRTZGLE1BQU0sR0FBSTtnQkFDL0J4SCxPQUFPd0wsR0FBRyxDQUFDaEUsRUFBRSxDQUFDeEg7WUFDbEI7UUFDSjtRQUNBLE9BQU9BLEtBQUtpRyxLQUFLbUgsTUFBTXpELE9BQU8yRCxPQUFPLEVBQUUzRDtJQUMzQztBQUNKO0FBRUEsMkVBQTJFO0FBQzNFLDRCQUE0QjtBQUM1QixJQUFJNEQsb0JBQW9CLFNBQVV0SCxHQUFHLEVBQUV1SCxTQUFTLEVBQUV6SSxRQUFRO0lBQ3RELElBQUkwSSxvQkFBb0JELFNBQVMsQ0FBQ3ZILElBQUksSUFBS3VILENBQUFBLFNBQVMsQ0FBQ3ZILElBQUksR0FBRyxFQUFFO0lBQzlEd0gsa0JBQWtCN0wsSUFBSSxDQUFDbUQ7SUFDdkIsT0FBTztRQUNILElBQUl6QixRQUFRbUssa0JBQWtCQyxPQUFPLENBQUMzSTtRQUN0QyxJQUFJekIsU0FBUyxHQUFHO1lBQ1osMkJBQTJCO1lBQzNCbUssaUJBQWlCLENBQUNuSyxNQUFNLEdBQUdtSyxpQkFBaUIsQ0FBQ0Esa0JBQWtCOUwsTUFBTSxHQUFHLEVBQUU7WUFDMUU4TCxrQkFBa0IvTCxHQUFHO1FBQ3pCO0lBQ0o7QUFDSjtBQUVBLElBQUlpTSxjQUFjO0lBQUVDLFFBQVE7QUFBSztBQUNqQyxJQUFJQyxnQkFBZ0IsU0FBVS9GLElBQUksRUFBRXdGLE9BQU8sRUFBRTNELE1BQU07SUFDL0MsSUFBSS9DLFFBQVErQyxPQUFPL0MsS0FBSyxFQUFFcUUsVUFBVXRCLE9BQU9zQixPQUFPLEVBQUU2QyxlQUFlbkUsT0FBT21FLFlBQVksRUFBRUMsV0FBV3BFLE9BQU9vRSxRQUFRLEVBQUVDLG9CQUFvQnJFLE9BQU9xRSxpQkFBaUIsRUFBRUMsa0JBQWtCdEUsT0FBT3NFLGVBQWUsRUFBRUMsb0JBQW9CdkUsT0FBT3VFLGlCQUFpQixFQUFFQyxxQkFBcUJ4RSxPQUFPd0Usa0JBQWtCO0lBQ3hTLElBQUlqSCxLQUFLWCxlQUFlL0MsR0FBRyxDQUFDb0QsUUFBUU8scUJBQXFCRCxFQUFFLENBQUMsRUFBRSxFQUFFRSxpQkFBaUJGLEVBQUUsQ0FBQyxFQUFFLEVBQUVxQixXQUFXckIsRUFBRSxDQUFDLEVBQUUsRUFBRUcsUUFBUUgsRUFBRSxDQUFDLEVBQUU7SUFDdkgseUVBQXlFO0lBQ3pFLG9EQUFvRDtJQUNwRCx1Q0FBdUM7SUFDdkMsOEVBQThFO0lBQzlFLGtCQUFrQjtJQUNsQixJQUFJb0IsS0FBS3RDLFVBQVU4QixPQUFPN0IsTUFBTXFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU4RixTQUFTOUYsRUFBRSxDQUFDLEVBQUUsRUFBRUQsVUFBVUMsRUFBRSxDQUFDLEVBQUU7SUFDdEUsMkNBQTJDO0lBQzNDLElBQUkrRixvQkFBb0JwUCw2Q0FBTUEsQ0FBQztJQUMvQiw4RUFBOEU7SUFDOUUsaUNBQWlDO0lBQ2pDLElBQUltTixlQUFlbk4sNkNBQU1BLENBQUM7SUFDMUIsbUNBQW1DO0lBQ25DLElBQUlxUCxTQUFTclAsNkNBQU1BLENBQUNnSDtJQUNwQixJQUFJc0ksYUFBYXRQLDZDQUFNQSxDQUFDcU87SUFDeEIsSUFBSWtCLFlBQVl2UCw2Q0FBTUEsQ0FBQzBLO0lBQ3ZCLElBQUk4RSxZQUFZO1FBQWMsT0FBT0QsVUFBVTVCLE9BQU87SUFBRTtJQUN4RCxJQUFJOEIsV0FBVztRQUFjLE9BQU9ELFlBQVk3SixTQUFTLE1BQU02SixZQUFZdkssUUFBUTtJQUFJO0lBQ3ZGLElBQUl5SyxpQkFBaUIsU0FBVUMsSUFBSTtRQUMvQixPQUFPaEksTUFBTW5ELEdBQUcsQ0FBQzRFLFNBQVNsRyxhQUFheUUsTUFBTXBELEdBQUcsQ0FBQzZFLFVBQVV1RztJQUMvRDtJQUNBLGdEQUFnRDtJQUNoRCxJQUFJQyxTQUFTakksTUFBTXBELEdBQUcsQ0FBQ3lDO0lBQ3ZCLElBQUlvRixXQUFXcEosWUFBWTZMLGdCQUNyQm5FLE9BQU8wQixRQUFRLENBQUNwRixJQUFJLEdBQ3BCNkg7SUFDTixJQUFJakgsT0FBTzVFLFlBQVk0TSxVQUFVeEQsV0FBV3dEO0lBQzVDLElBQUlELE9BQU9oSSxNQUFNcEQsR0FBRyxDQUFDNkUsWUFBWSxDQUFDO0lBQ2xDLElBQUl2QixRQUFROEgsS0FBSzlILEtBQUs7SUFDdEIsSUFBSWdJLGlCQUFpQixDQUFDVCxrQkFBa0J6QixPQUFPO0lBQy9DLGlFQUFpRTtJQUNqRSx3RkFBd0Y7SUFDeEYsOERBQThEO0lBQzlELElBQUltQyxtQkFBbUI7UUFDbkIsNkRBQTZEO1FBQzdELElBQUlELGtCQUFrQixDQUFDN00sWUFBWStMLG9CQUMvQixPQUFPQTtRQUNYLHdDQUF3QztRQUN4QyxJQUFJUyxZQUFZckQsUUFBUSxJQUNwQixPQUFPO1FBQ1gscUVBQXFFO1FBQ3JFLGtFQUFrRTtRQUNsRSxrRUFBa0U7UUFDbEUsSUFBSTJDLFVBQ0EsT0FBTzlMLFlBQVk0RSxRQUFRLFFBQVE4QyxPQUFPaUIsaUJBQWlCO1FBQy9ELDZEQUE2RDtRQUM3RCxvRUFBb0U7UUFDcEUsT0FBTzNJLFlBQVk0RSxTQUFTOEMsT0FBT2lCLGlCQUFpQjtJQUN4RDtJQUNBLHdDQUF3QztJQUN4QyxJQUFJb0Usb0JBQW9CO1FBQ3BCLElBQUksQ0FBQy9JLE9BQU8sQ0FBQ3FILFNBQ1QsT0FBTztRQUNYLElBQUlzQixLQUFLN0gsWUFBWSxFQUNqQixPQUFPO1FBQ1gseUVBQXlFO1FBQ3pFLE9BQU8rSCxrQkFBa0JDO0lBQzdCO0lBQ0EsSUFBSWhJLGVBQWVpSTtJQUNuQixJQUFJbkcsS0FBS3FELGlCQUFpQjtRQUN0QnJGLE1BQU1BO1FBQ05DLE9BQU9BO1FBQ1BDLGNBQWNBO0lBQ2xCLEdBQUdxRixlQUFlRSxXQUFXekQsRUFBRSxDQUFDLEVBQUUsRUFBRW9HLG9CQUFvQnBHLEVBQUUsQ0FBQyxFQUFFLEVBQUUyRCxXQUFXM0QsRUFBRSxDQUFDLEVBQUU7SUFDL0UsMkVBQTJFO0lBQzNFLHNEQUFzRDtJQUN0RCxJQUFJN0IsYUFBYTlILGtEQUFXQSxDQUFDLFNBQVVnUSxjQUFjO1FBQUksT0FBTzlQLFVBQVUsS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDOUYsSUFBSStQLGdCQUFnQmhFLFNBQVNpRSxTQUFTQyxTQUFTbEcsTUFBTW1HLHVCQUF1QkMscUJBQXFCQyxjQUFjQyxVQUFVQyw2QkFBNkJDLGNBQWNDO1lBQ3BLLElBQUkxSTtZQUNKLE9BQU8zRyxZQUFZLElBQUksRUFBRSxTQUFVK0gsRUFBRTtnQkFDakMsT0FBUUEsR0FBRzVILEtBQUs7b0JBQ1osS0FBSzt3QkFDRHlPLGlCQUFpQlosV0FBVzNCLE9BQU87d0JBQ25DLElBQUksQ0FBQzNHLE9BQ0QsQ0FBQ2tKLGtCQUNEL0MsYUFBYVEsT0FBTyxJQUNwQjZCLFlBQVlyRCxRQUFRLElBQUk7NEJBQ3hCLE9BQU87Z0NBQUMsRUFBRSxRQUFRO2dDQUFJOzZCQUFNO3dCQUNoQzt3QkFDQWlFLFVBQVU7d0JBQ1ZsRyxPQUFPK0Ysa0JBQWtCLENBQUM7d0JBQzFCSSx3QkFBd0IsQ0FBQ2pJLEtBQUssQ0FBQ3BCLElBQUksSUFBSSxDQUFDa0QsS0FBS3lFLE1BQU07d0JBQ25EMkIsc0JBQXNCOzRCQUNsQixPQUFPLENBQUNuRCxhQUFhUSxPQUFPLElBQ3hCM0csUUFBUXFJLE9BQU8xQixPQUFPLElBQ3RCeUIsa0JBQWtCekIsT0FBTzt3QkFDakM7d0JBQ0E0QyxlQUFlOzRCQUNYLHdEQUF3RDs0QkFDeEQsSUFBSUssY0FBY3hJLEtBQUssQ0FBQ3BCLElBQUk7NEJBQzVCLElBQUk0SixlQUFlQSxXQUFXLENBQUMsRUFBRSxLQUFLVCxTQUFTO2dDQUMzQyxPQUFPL0gsS0FBSyxDQUFDcEIsSUFBSTs0QkFDckI7d0JBQ0o7d0JBQ0F3SixXQUFXOzRCQUFFMUksY0FBYzt3QkFBTTt3QkFDakMySSw4QkFBOEI7NEJBQzFCZixlQUFlO2dDQUFFNUgsY0FBYzs0QkFBTTs0QkFDckMsd0VBQXdFOzRCQUN4RSxJQUFJd0ksdUJBQXVCO2dDQUN2Qi9DLFNBQVNpRDs0QkFDYjt3QkFDSjt3QkFDQSxxRUFBcUU7d0JBQ3JFZCxlQUFlOzRCQUNYNUgsY0FBYzt3QkFDbEI7d0JBQ0F5RixTQUFTOzRCQUFFekYsY0FBYzt3QkFBSzt3QkFDOUJ1QixHQUFHNUgsS0FBSyxHQUFHO29CQUNmLEtBQUs7d0JBQ0Q0SCxHQUFHekgsSUFBSSxDQUFDZSxJQUFJLENBQUM7NEJBQUM7NEJBQUc7OzRCQUFLO3lCQUFFO3dCQUN4QixJQUFJME4sdUJBQXVCOzRCQUN2QiwyREFBMkQ7NEJBQzNEM0ksZUFBZUMsT0FBT1gsS0FBS3FHLFNBQVNNLE9BQU8sQ0FBQy9GLElBQUksRUFBRXlGLFNBQVNNLE9BQU8sQ0FBQzlGLEtBQUssRUFBRTs0QkFDMUUsZ0VBQWdFOzRCQUNoRSxxQ0FBcUM7NEJBQ3JDLElBQUk2QyxPQUFPcUIsY0FBYyxJQUFJLENBQUNwRSxNQUFNcEQsR0FBRyxDQUFDeUMsTUFBTTtnQ0FDMUNWLFdBQVc7b0NBQ1AsSUFBSThKLFdBQVdFLHVCQUF1Qjt3Q0FDbENkLFlBQVluRSxhQUFhLENBQUNyRSxLQUFLMEQ7b0NBQ25DO2dDQUNKLEdBQUdBLE9BQU9xQixjQUFjOzRCQUM1Qjs0QkFDQSw0Q0FBNEM7NEJBQzVDM0QsS0FBSyxDQUFDcEIsSUFBSSxHQUFHO2dDQUFDa0osZUFBZTdPLEtBQUssQ0FBQyxLQUFLLEdBQUc4TjtnQ0FBUzFHOzZCQUFlO3dCQUN2RTt3QkFDQVIsS0FBS0csS0FBSyxDQUFDcEIsSUFBSSxFQUFFa0YsVUFBVWpFLEVBQUUsQ0FBQyxFQUFFLEVBQUVrSSxVQUFVbEksRUFBRSxDQUFDLEVBQUU7d0JBQ2pELE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJaUU7eUJBQVE7b0JBQ2pDLEtBQUs7d0JBQ0RBLFVBQVU3QyxHQUFHM0gsSUFBSTt3QkFDakIsSUFBSTJPLHVCQUF1Qjs0QkFDdkIsMERBQTBEOzRCQUMxRCwwQkFBMEI7NEJBQzFCL0osV0FBV2lLLGNBQWM3RixPQUFPb0IsZ0JBQWdCO3dCQUNwRDt3QkFDQSx1RUFBdUU7d0JBQ3ZFLHVFQUF1RTt3QkFDdkUscURBQXFEO3dCQUNyRCxtQ0FBbUM7d0JBQ25DLG9EQUFvRDt3QkFDcEQsaURBQWlEO3dCQUNqRCxJQUFJLENBQUMxRCxLQUFLLENBQUNwQixJQUFJLElBQUlvQixLQUFLLENBQUNwQixJQUFJLENBQUMsRUFBRSxLQUFLbUosU0FBUzs0QkFDMUMsSUFBSUUsdUJBQXVCO2dDQUN2QixJQUFJQyx1QkFBdUI7b0NBQ3ZCZCxZQUFZaEUsV0FBVyxDQUFDeEU7Z0NBQzVCOzRCQUNKOzRCQUNBLE9BQU87Z0NBQUMsRUFBRSxRQUFRO2dDQUFJOzZCQUFNO3dCQUNoQzt3QkFDQSxlQUFlO3dCQUNmMEksZUFBZTs0QkFDWDdILE9BQU9oRjt3QkFDWDt3QkFDQTJOLFNBQVMzSSxLQUFLLEdBQUdoRjt3QkFDakI2TixlQUFlcEgsUUFBUSxDQUFDdEMsSUFBSTt3QkFDNUIsSUFBSSxDQUFDaEUsWUFBWTBOLGlCQUNiLFNBQVM7d0JBQ1JQLENBQUFBLFdBQVdPLFlBQVksQ0FBQyxFQUFFLElBQ3ZCLFNBQVM7d0JBQ1RQLFdBQVdPLFlBQVksQ0FBQyxFQUFFLElBQzFCLFNBQVM7d0JBQ1RBLFlBQVksQ0FBQyxFQUFFLEtBQUssSUFBSTs0QkFDNUJEOzRCQUNBLElBQUlKLHVCQUF1QjtnQ0FDdkIsSUFBSUMsdUJBQXVCO29DQUN2QmQsWUFBWWhFLFdBQVcsQ0FBQ3hFO2dDQUM1Qjs0QkFDSjs0QkFDQSxPQUFPO2dDQUFDLEVBQUUsUUFBUTtnQ0FBSTs2QkFBTTt3QkFDaEM7d0JBQ0EsNERBQTREO3dCQUM1RCx1Q0FBdUM7d0JBQ3ZDLElBQUksQ0FBQ2dGLFFBQVFxQixTQUFTTSxPQUFPLENBQUMvRixJQUFJLEVBQUVzRSxVQUFVOzRCQUMxQ3NFLFNBQVM1SSxJQUFJLEdBQUdzRTt3QkFDcEIsT0FDSzs0QkFDRCxvQ0FBb0M7NEJBQ3BDLGdEQUFnRDs0QkFDaERzRSxTQUFTNUksSUFBSSxHQUFHeUYsU0FBU00sT0FBTyxDQUFDL0YsSUFBSTt3QkFDckMsb0ZBQW9GO3dCQUNwRiw2Q0FBNkM7d0JBQ2pEO3dCQUNBLDREQUE0RDt3QkFDNUQsMENBQTBDO3dCQUMxQyxJQUFJLENBQUNvRSxRQUFRckUsTUFBTXBELEdBQUcsQ0FBQ3lDLE1BQU1rRixVQUFVOzRCQUNuQ3ZFLE1BQU1uRCxHQUFHLENBQUN3QyxLQUFLa0Y7d0JBQ25CO3dCQUNBLGdFQUFnRTt3QkFDaEUsSUFBSW1FLHVCQUF1Qjs0QkFDdkIsSUFBSUMsdUJBQXVCO2dDQUN2QmQsWUFBWWxFLFNBQVMsQ0FBQ1ksU0FBU2xGLEtBQUswRDs0QkFDeEM7d0JBQ0o7d0JBQ0EsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUk7eUJBQUU7b0JBQzNCLEtBQUs7d0JBQ0RpRyxRQUFRdEgsR0FBRzNILElBQUk7d0JBQ2Y2Tzt3QkFDQSxvRUFBb0U7d0JBQ3BFLElBQUksQ0FBQ2YsWUFBWXJELFFBQVEsSUFBSTs0QkFDekIseURBQXlEOzRCQUN6RHVELGVBQWU7Z0NBQUU3SCxPQUFPOEk7NEJBQU07NEJBQzlCSCxTQUFTM0ksS0FBSyxHQUFHOEk7NEJBQ2pCLGdFQUFnRTs0QkFDaEUsZ0JBQWdCOzRCQUNoQixJQUFJTix5QkFBeUJDLHVCQUF1QjtnQ0FDaERkLFlBQVlqRSxPQUFPLENBQUNvRixPQUFPM0osS0FBSzBEO2dDQUNoQyxJQUFJLE9BQVFBLE9BQU9rQixrQkFBa0IsS0FBSyxhQUN0Q2xCLE9BQU9rQixrQkFBa0IsSUFDeEIzSSxXQUFXeUgsT0FBT2tCLGtCQUFrQixLQUNqQ2xCLE9BQU9rQixrQkFBa0IsQ0FBQytFLFFBQVM7b0NBQ3ZDLDBDQUEwQztvQ0FDMUMsSUFBSWxCLFlBQVk7d0NBQ1osZ0VBQWdFO3dDQUNoRSxtQkFBbUI7d0NBQ25CRCxZQUFZaEYsWUFBWSxDQUFDbUcsT0FBTzNKLEtBQUswRCxRQUFRM0MsWUFBWTs0Q0FDckQrQyxZQUFZLENBQUNaLEtBQUtZLFVBQVUsSUFBSSxLQUFLOzRDQUNyQzZELFFBQVE7d0NBQ1o7b0NBQ0o7Z0NBQ0o7NEJBQ0o7d0JBQ0o7d0JBQ0EsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUk7eUJBQUU7b0JBQzNCLEtBQUs7d0JBQ0QsMkJBQTJCO3dCQUMzQnlCLFVBQVU7d0JBQ1YsbUNBQW1DO3dCQUNuQ0s7d0JBQ0EscUVBQXFFO3dCQUNyRSx1QkFBdUI7d0JBQ3ZCLElBQUlILHlCQUF5QkQsdUJBQXVCOzRCQUNoRDNJLGVBQWVDLE9BQU9YLEtBQUt3SixTQUFTNUksSUFBSSxFQUFFNEksU0FBUzNJLEtBQUssRUFBRTt3QkFDOUQ7d0JBQ0EsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUk7eUJBQUs7Z0JBQ25DO1lBQ0o7UUFDSjtJQUFJLEdBQ0osc0VBQXNFO0lBQ3RFLDBFQUEwRTtJQUMxRSxrQkFBa0I7SUFDbEIsRUFBRTtJQUNGLFNBQVM7SUFDVCwyREFBMkQ7SUFDM0Qsb0RBQW9EO0lBQ3BELDREQUE0RDtJQUM1RCw0Q0FBNEM7SUFDNUMsbURBQW1EO0lBQ25ELHVEQUF1RDtJQUN2RDtRQUFDYjtLQUFJO0lBQ0wsd0VBQXdFO0lBQ3hFLHdEQUF3RDtJQUN4RCx1REFBdUQ7SUFDdkQsSUFBSTZKLGNBQWM1USxrREFBV0EsQ0FDN0IsMEVBQTBFO0lBQzFFLDBFQUEwRTtJQUMxRSwwQkFBMEI7SUFDMUJ5SSxlQUFlcEQsSUFBSSxDQUFDekMsV0FBVzhFLE9BQU87UUFBYyxPQUFPMEgsT0FBTzFCLE9BQU87SUFBRSxJQUMzRSx1REFBdUQ7SUFDdkQsRUFBRTtJQUNGLHlDQUF5QztJQUN6Q3BILDBCQUEwQjtRQUN0QitJLFdBQVczQixPQUFPLEdBQUdVO1FBQ3JCa0IsVUFBVTVCLE9BQU8sR0FBR2pEO0lBQ3hCO0lBQ0EsZ0NBQWdDO0lBQ2hDbkUsMEJBQTBCO1FBQ3RCLElBQUksQ0FBQ1MsS0FDRDtRQUNKLElBQUk4SixhQUFhOUosUUFBUXFJLE9BQU8xQixPQUFPO1FBQ3ZDLElBQUlvRCxpQkFBaUJoSixXQUFXekMsSUFBSSxDQUFDekMsV0FBVzZMO1FBQ2hELDBFQUEwRTtRQUMxRSxtQ0FBbUM7UUFDbkMsSUFBSXNDLGdCQUFnQixTQUFVQyxXQUFXLEVBQUVDLFlBQVksRUFBRUMsbUJBQW1CO1lBQ3hFNUQsU0FBU3JLLGFBQWE7Z0JBQ2xCMkUsT0FBT3FKO2dCQUNQcEosY0FBY3FKO1lBQ2xCLEdBQ0EsZ0VBQWdFO1lBQ2hFLG1CQUFtQjtZQUNuQm5GLFFBQVFxQixTQUFTTSxPQUFPLENBQUMvRixJQUFJLEVBQUVxSixlQUN6QnBPLFlBQ0E7Z0JBQ0UrRSxNQUFNcUo7WUFDVjtRQUNSO1FBQ0EsbUVBQW1FO1FBQ25FLGlDQUFpQztRQUNqQyxJQUFJRyx5QkFBeUI7UUFDN0IsSUFBSUMsZUFBZSxTQUFVcE4sSUFBSTtZQUM3QixJQUFJQSxRQUFRc0QsYUFBYTtnQkFDckIsSUFBSStKLE1BQU1sTixLQUFLa04sR0FBRztnQkFDbEIsSUFBSTlCLFlBQVkvRCxpQkFBaUIsSUFDN0I2RixNQUFNRiwwQkFDTjNCLFlBQVk7b0JBQ1oyQix5QkFBeUJFLE1BQU05QixZQUFZM0QscUJBQXFCO29CQUNoRWtGO2dCQUNKO1lBQ0osT0FDSyxJQUFJOU0sUUFBUXVELGlCQUFpQjtnQkFDOUIsSUFBSWdJLFlBQVk5RCxxQkFBcUIsSUFBSStELFlBQVk7b0JBQ2pEc0I7Z0JBQ0o7WUFDSixPQUNLLElBQUk5TSxRQUFRd0QsY0FBYztnQkFDM0IsT0FBT007WUFDWDtZQUNBO1FBQ0o7UUFDQSxJQUFJd0osY0FBY2pELGtCQUFrQnRILEtBQUttQixnQkFBZ0I2STtRQUN6RCxJQUFJUSxjQUFjbEQsa0JBQWtCdEgsS0FBS2tCLG9CQUFvQm1KO1FBQzdELCtEQUErRDtRQUMvRGxFLGFBQWFRLE9BQU8sR0FBRztRQUN2QjBCLE9BQU8xQixPQUFPLEdBQUczRztRQUNqQm9JLGtCQUFrQnpCLE9BQU8sR0FBRztRQUM1QiwyREFBMkQ7UUFDM0QsdUNBQXVDO1FBQ3ZDLElBQUltRCxZQUFZO1lBQ1p2RCxTQUFTO2dCQUNMM0YsTUFBTUE7Z0JBQ05DLE9BQU9BO2dCQUNQQyxjQUFjQTtZQUNsQjtRQUNKO1FBQ0EsMEJBQTBCO1FBQzFCLElBQUlnSSxvQkFBb0I7WUFDcEIsSUFBSTlNLFlBQVk0RSxTQUFTeEIsV0FBVztnQkFDaEMsMEJBQTBCO2dCQUMxQjJLO1lBQ0osT0FDSztnQkFDRCxtRUFBbUU7Z0JBQ25FLGFBQWE7Z0JBQ2IxSyxJQUFJMEs7WUFDUjtRQUNKO1FBQ0EsT0FBTztZQUNILHdCQUF3QjtZQUN4QjVELGFBQWFRLE9BQU8sR0FBRztZQUN2QjREO1lBQ0FDO1FBQ0o7SUFDSixHQUFHO1FBQUN4SztRQUFLZTtLQUFXO0lBQ3BCLFVBQVU7SUFDVnhCLDBCQUEwQjtRQUN0QixJQUFJa0w7UUFDSixTQUFTMVE7WUFDTCwwQkFBMEI7WUFDMUIsc0VBQXNFO1lBQ3RFLElBQUkyUSxXQUFXek8sV0FBVytMLG1CQUNwQkEsZ0JBQWdCcEgsUUFDaEJvSDtZQUNOLGtFQUFrRTtZQUNsRSxtREFBbUQ7WUFDbkQsZ0VBQWdFO1lBQ2hFLElBQUkwQyxZQUFZRCxVQUFVLENBQUMsR0FBRztnQkFDMUJBLFFBQVFuTCxXQUFXcUwsU0FBU0Q7WUFDaEM7UUFDSjtRQUNBLFNBQVNDO1lBQ0wsK0JBQStCO1lBQy9CLG9FQUFvRTtZQUNwRSxJQUFJLENBQUN0RSxTQUFTTSxPQUFPLENBQUM5RixLQUFLLElBQ3RCb0gsQ0FBQUEscUJBQXFCTyxZQUFZN0osU0FBUyxFQUFDLEtBQzNDdUosQ0FBQUEsc0JBQXNCTSxZQUFZdkssUUFBUSxFQUFDLEdBQUk7Z0JBQ2hEOEMsV0FBVzJHLGFBQWF0TixJQUFJLENBQUNMO1lBQ2pDLE9BQ0s7Z0JBQ0QseUNBQXlDO2dCQUN6Q0E7WUFDSjtRQUNKO1FBQ0FBO1FBQ0EsT0FBTztZQUNILElBQUkwUSxPQUFPO2dCQUNQRyxhQUFhSDtnQkFDYkEsUUFBUSxDQUFDO1lBQ2I7UUFDSjtJQUNKLEdBQUc7UUFBQ3pDO1FBQWlCQztRQUFtQkM7UUFBb0JuSDtLQUFXO0lBQ3ZFLHdDQUF3QztJQUN4QzdILG9EQUFhQSxDQUFDMEg7SUFDZCw0REFBNEQ7SUFDNUQsNkVBQTZFO0lBQzdFLDJFQUEyRTtJQUMzRSx5QkFBeUI7SUFDekIsSUFBSWtILFlBQVk5TCxZQUFZNEUsU0FBU1osS0FBSztRQUN0QyxxRUFBcUU7UUFDckVzSSxXQUFXM0IsT0FBTyxHQUFHVTtRQUNyQmtCLFVBQVU1QixPQUFPLEdBQUdqRDtRQUNwQnlDLGFBQWFRLE9BQU8sR0FBRztRQUN2QixNQUFNM0ssWUFBWTZFLFNBQVNFLFdBQVcyRyxlQUFlN0c7SUFDekQ7SUFDQSxPQUFPO1FBQ0hzQyxRQUFRMEc7UUFDUixJQUFJakosUUFBTztZQUNQb0ksa0JBQWtCcEksSUFBSSxHQUFHO1lBQ3pCLE9BQU9BO1FBQ1g7UUFDQSxJQUFJQyxTQUFRO1lBQ1JtSSxrQkFBa0JuSSxLQUFLLEdBQUc7WUFDMUIsT0FBT0E7UUFDWDtRQUNBLElBQUlDLGdCQUFlO1lBQ2ZrSSxrQkFBa0JsSSxZQUFZLEdBQUc7WUFDakMsT0FBT0E7UUFDWDtJQUNKO0FBQ0o7QUFDQSxJQUFJK0osWUFBWS9PLE9BQU9nUCxjQUFjLENBQUNsRixhQUFhLFdBQVc7SUFDMURuTSxPQUFPMks7QUFDWDtBQUNBLElBQUkyRyxxQkFBcUIsU0FBVS9LLEdBQUc7SUFBSSxPQUFPRCxVQUFVQyxJQUFJLENBQUMsRUFBRTtBQUFFO0FBQ3BFLElBQUlnTCxTQUFTakUsU0FBU2E7QUFFdEIsU0FBUztBQUV5RSIsInNvdXJjZXMiOlsid2VicGFjazovL2JyZWV6ZS1uZXh0Ly4uLy4uL25vZGVfbW9kdWxlcy9zd3IvZGlzdC9pbmRleC5tanM/OGJhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIGNyZWF0ZUVsZW1lbnQsIHVzZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZURlYnVnVmFsdWUgfSBmcm9tICdyZWFjdCc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcbi8vIFVzaW5nIG5vb3AoKSBhcyB0aGUgdW5kZWZpbmVkIHZhbHVlIGFzIHVuZGVmaW5lZCBjYW4gcG9zc2libHkgYmUgcmVwbGFjZWRcbi8vIGJ5IHNvbWV0aGluZyBlbHNlLiAgUHJldHRpZXIgaWdub3JlIGFuZCBleHRyYSBwYXJlbnRoZXNlcyBhcmUgbmVjZXNzYXJ5IGhlcmVcbi8vIHRvIGVuc3VyZSB0aGF0IHRzYyBkb2Vzbid0IHJlbW92ZSB0aGUgX19OT0lOTElORV9fIGNvbW1lbnQuXG4vLyBwcmV0dGllci1pZ25vcmVcbnZhciBVTkRFRklORUQgPSAoIC8qI19fTk9JTkxJTkVfXyovbm9vcCgpKTtcbnZhciBPQkpFQ1QgPSBPYmplY3Q7XG52YXIgaXNVbmRlZmluZWQgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdiA9PT0gVU5ERUZJTkVEOyB9O1xudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdHlwZW9mIHYgPT0gJ2Z1bmN0aW9uJzsgfTtcbnZhciBtZXJnZU9iamVjdHMgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gT0JKRUNULmFzc2lnbih7fSwgYSwgYik7IH07XG52YXIgU1RSX1VOREVGSU5FRCA9ICd1bmRlZmluZWQnO1xuLy8gTk9URTogVXNlIGZ1bmN0aW9uIHRvIGd1YXJhbnRlZSBpdCdzIHJlLWV2YWx1YXRlZCBiZXR3ZWVuIGpzZG9tIGFuZCBub2RlIHJ1bnRpbWUgZm9yIHRlc3RzLlxudmFyIGhhc1dpbmRvdyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT0gU1RSX1VOREVGSU5FRDsgfTtcbnZhciBoYXNEb2N1bWVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCAhPSBTVFJfVU5ERUZJTkVEOyB9O1xudmFyIGhhc1JlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaGFzV2luZG93KCkgJiYgdHlwZW9mIHdpbmRvd1sncmVxdWVzdEFuaW1hdGlvbkZyYW1lJ10gIT0gU1RSX1VOREVGSU5FRDtcbn07XG5cbi8vIHVzZSBXZWFrTWFwIHRvIHN0b3JlIHRoZSBvYmplY3QtPmtleSBtYXBwaW5nXG4vLyBzbyB0aGUgb2JqZWN0cyBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4vLyBXZWFrTWFwIHVzZXMgYSBoYXNodGFibGUgdW5kZXIgdGhlIGhvb2QsIHNvIHRoZSBsb29rdXBcbi8vIGNvbXBsZXhpdHkgaXMgYWxtb3N0IE8oMSkuXG52YXIgdGFibGUgPSBuZXcgV2Vha01hcCgpO1xuLy8gY291bnRlciBvZiB0aGUga2V5XG52YXIgY291bnRlciA9IDA7XG4vLyBBIHN0YWJsZSBoYXNoIGltcGxlbWVudGF0aW9uIHRoYXQgc3VwcG9ydHM6XG4vLyAtIEZhc3QgYW5kIGVuc3VyZXMgdW5pcXVlIGhhc2ggcHJvcGVydGllc1xuLy8gLSBIYW5kbGVzIHVuc2VyaWFsaXphYmxlIHZhbHVlc1xuLy8gLSBIYW5kbGVzIG9iamVjdCBrZXkgb3JkZXJpbmdcbi8vIC0gR2VuZXJhdGVzIHNob3J0IHJlc3VsdHNcbi8vXG4vLyBUaGlzIGlzIG5vdCBhIHNlcmlhbGl6YXRpb24gZnVuY3Rpb24sIGFuZCB0aGUgcmVzdWx0IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlXG4vLyBwYXJzaWJsZS5cbnZhciBzdGFibGVIYXNoID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGFyZztcbiAgICB2YXIgY29uc3RydWN0b3IgPSBhcmcgJiYgYXJnLmNvbnN0cnVjdG9yO1xuICAgIHZhciBpc0RhdGUgPSBjb25zdHJ1Y3RvciA9PSBEYXRlO1xuICAgIHZhciByZXN1bHQ7XG4gICAgdmFyIGluZGV4O1xuICAgIGlmIChPQkpFQ1QoYXJnKSA9PT0gYXJnICYmICFpc0RhdGUgJiYgY29uc3RydWN0b3IgIT0gUmVnRXhwKSB7XG4gICAgICAgIC8vIE9iamVjdC9mdW5jdGlvbiwgbm90IG51bGwvZGF0ZS9yZWdleHAuIFVzZSBXZWFrTWFwIHRvIHN0b3JlIHRoZSBpZCBmaXJzdC5cbiAgICAgICAgLy8gSWYgaXQncyBhbHJlYWR5IGhhc2hlZCwgZGlyZWN0bHkgcmV0dXJuIHRoZSByZXN1bHQuXG4gICAgICAgIHJlc3VsdCA9IHRhYmxlLmdldChhcmcpO1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgLy8gU3RvcmUgdGhlIGhhc2ggZmlyc3QgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3Rpb24gYmVmb3JlIGVudGVyaW5nIHRoZVxuICAgICAgICAvLyByZWN1cnNpdmUgYHN0YWJsZUhhc2hgIGNhbGxzLlxuICAgICAgICAvLyBGb3Igb3RoZXIgb2JqZWN0cyBsaWtlIHNldCBhbmQgbWFwLCB3ZSB1c2UgdGhpcyBpZCBkaXJlY3RseSBhcyB0aGUgaGFzaC5cbiAgICAgICAgcmVzdWx0ID0gKytjb3VudGVyICsgJ34nO1xuICAgICAgICB0YWJsZS5zZXQoYXJnLCByZXN1bHQpO1xuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT0gQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIEFycmF5LlxuICAgICAgICAgICAgcmVzdWx0ID0gJ0AnO1xuICAgICAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgYXJnLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdGFibGVIYXNoKGFyZ1tpbmRleF0pICsgJywnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFibGUuc2V0KGFyZywgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT0gT0JKRUNUKSB7XG4gICAgICAgICAgICAvLyBPYmplY3QsIHNvcnQga2V5cy5cbiAgICAgICAgICAgIHJlc3VsdCA9ICcjJztcbiAgICAgICAgICAgIHZhciBrZXlzID0gT0JKRUNULmtleXMoYXJnKS5zb3J0KCk7XG4gICAgICAgICAgICB3aGlsZSAoIWlzVW5kZWZpbmVkKChpbmRleCA9IGtleXMucG9wKCkpKSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoYXJnW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGluZGV4ICsgJzonICsgc3RhYmxlSGFzaChhcmdbaW5kZXhdKSArICcsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWJsZS5zZXQoYXJnLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBpc0RhdGVcbiAgICAgICAgICAgID8gYXJnLnRvSlNPTigpXG4gICAgICAgICAgICA6IHR5cGUgPT0gJ3N5bWJvbCdcbiAgICAgICAgICAgICAgICA/IGFyZy50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgOiB0eXBlID09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkoYXJnKVxuICAgICAgICAgICAgICAgICAgICA6ICcnICsgYXJnO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBEdWUgdG8gYnVnIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTY3ODA3NSxcbiAqIGl0J3Mgbm90IHJlbGlhYmxlIHRvIGRldGVjdCBpZiB0aGUgYnJvd3NlciBpcyBjdXJyZW50bHkgb25saW5lIG9yIG9mZmxpbmVcbiAqIGJhc2VkIG9uIGBuYXZpZ2F0b3Iub25MaW5lYC5cbiAqIEFzIGEgd29yayBhcm91bmQsIHdlIGFsd2F5cyBhc3N1bWUgaXQncyBvbmxpbmUgb24gZmlyc3QgbG9hZCwgYW5kIGNoYW5nZVxuICogdGhlIHN0YXR1cyB1cG9uIGBvbmxpbmVgIG9yIGBvZmZsaW5lYCBldmVudHMuXG4gKi9cbnZhciBvbmxpbmUgPSB0cnVlO1xudmFyIGlzT25saW5lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb25saW5lOyB9O1xudmFyIGhhc1dpbiA9IGhhc1dpbmRvdygpO1xudmFyIGhhc0RvYyA9IGhhc0RvY3VtZW50KCk7XG4vLyBGb3Igbm9kZSBhbmQgUmVhY3QgTmF0aXZlLCBgYWRkL3JlbW92ZUV2ZW50TGlzdGVuZXJgIGRvZXNuJ3QgZXhpc3Qgb24gd2luZG93LlxudmFyIG9uV2luZG93RXZlbnQgPSBoYXNXaW4gJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA/IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyLmJpbmQod2luZG93KVxuICAgIDogbm9vcDtcbnZhciBvbkRvY3VtZW50RXZlbnQgPSBoYXNEb2MgPyBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyLmJpbmQoZG9jdW1lbnQpIDogbm9vcDtcbnZhciBvZmZXaW5kb3dFdmVudCA9IGhhc1dpbiAmJiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgID8gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIuYmluZCh3aW5kb3cpXG4gICAgOiBub29wO1xudmFyIG9mZkRvY3VtZW50RXZlbnQgPSBoYXNEb2NcbiAgICA/IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIuYmluZChkb2N1bWVudClcbiAgICA6IG5vb3A7XG52YXIgaXNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2aXNpYmlsaXR5U3RhdGUgPSBoYXNEb2MgJiYgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlO1xuICAgIHJldHVybiBpc1VuZGVmaW5lZCh2aXNpYmlsaXR5U3RhdGUpIHx8IHZpc2liaWxpdHlTdGF0ZSAhPT0gJ2hpZGRlbic7XG59O1xudmFyIGluaXRGb2N1cyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vIGZvY3VzIHJldmFsaWRhdGVcbiAgICBvbkRvY3VtZW50RXZlbnQoJ3Zpc2liaWxpdHljaGFuZ2UnLCBjYWxsYmFjayk7XG4gICAgb25XaW5kb3dFdmVudCgnZm9jdXMnLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2ZmRG9jdW1lbnRFdmVudCgndmlzaWJpbGl0eWNoYW5nZScsIGNhbGxiYWNrKTtcbiAgICAgICAgb2ZmV2luZG93RXZlbnQoJ2ZvY3VzJywgY2FsbGJhY2spO1xuICAgIH07XG59O1xudmFyIGluaXRSZWNvbm5lY3QgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAvLyByZXZhbGlkYXRlIG9uIHJlY29ubmVjdGVkXG4gICAgdmFyIG9uT25saW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvbmxpbmUgPSB0cnVlO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH07XG4gICAgLy8gbm90aGluZyB0byByZXZhbGlkYXRlLCBqdXN0IHVwZGF0ZSB0aGUgc3RhdHVzXG4gICAgdmFyIG9uT2ZmbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb25saW5lID0gZmFsc2U7XG4gICAgfTtcbiAgICBvbldpbmRvd0V2ZW50KCdvbmxpbmUnLCBvbk9ubGluZSk7XG4gICAgb25XaW5kb3dFdmVudCgnb2ZmbGluZScsIG9uT2ZmbGluZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2ZmV2luZG93RXZlbnQoJ29ubGluZScsIG9uT25saW5lKTtcbiAgICAgICAgb2ZmV2luZG93RXZlbnQoJ29mZmxpbmUnLCBvbk9mZmxpbmUpO1xuICAgIH07XG59O1xudmFyIHByZXNldCA9IHtcbiAgICBpc09ubGluZTogaXNPbmxpbmUsXG4gICAgaXNWaXNpYmxlOiBpc1Zpc2libGVcbn07XG52YXIgZGVmYXVsdENvbmZpZ09wdGlvbnMgPSB7XG4gICAgaW5pdEZvY3VzOiBpbml0Rm9jdXMsXG4gICAgaW5pdFJlY29ubmVjdDogaW5pdFJlY29ubmVjdFxufTtcblxudmFyIElTX1NFUlZFUiA9ICFoYXNXaW5kb3coKSB8fCAnRGVubycgaW4gd2luZG93O1xuLy8gUG9seWZpbGwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG52YXIgckFGID0gZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gaGFzUmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkgPyB3aW5kb3dbJ3JlcXVlc3RBbmltYXRpb25GcmFtZSddKGYpIDogc2V0VGltZW91dChmLCAxKTtcbn07XG4vLyBSZWFjdCBjdXJyZW50bHkgdGhyb3dzIGEgd2FybmluZyB3aGVuIHVzaW5nIHVzZUxheW91dEVmZmVjdCBvbiB0aGUgc2VydmVyLlxuLy8gVG8gZ2V0IGFyb3VuZCBpdCwgd2UgY2FuIGNvbmRpdGlvbmFsbHkgdXNlRWZmZWN0IG9uIHRoZSBzZXJ2ZXIgKG5vLW9wKSBhbmRcbi8vIHVzZUxheW91dEVmZmVjdCBpbiB0aGUgYnJvd3Nlci5cbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gSVNfU0VSVkVSID8gdXNlRWZmZWN0IDogdXNlTGF5b3V0RWZmZWN0O1xuLy8gVGhpcyBhc3NpZ25tZW50IGlzIHRvIGV4dGVuZCB0aGUgTmF2aWdhdG9yIHR5cGUgdG8gdXNlIGVmZmVjdGl2ZVR5cGUuXG52YXIgbmF2aWdhdG9yQ29ubmVjdGlvbiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgbmF2aWdhdG9yLmNvbm5lY3Rpb247XG4vLyBBZGp1c3QgdGhlIGNvbmZpZyBiYXNlZCBvbiBzbG93IGNvbm5lY3Rpb24gc3RhdHVzICg8PSA3MEticHMpLlxudmFyIHNsb3dDb25uZWN0aW9uID0gIUlTX1NFUlZFUiAmJlxuICAgIG5hdmlnYXRvckNvbm5lY3Rpb24gJiZcbiAgICAoWydzbG93LTJnJywgJzJnJ10uaW5jbHVkZXMobmF2aWdhdG9yQ29ubmVjdGlvbi5lZmZlY3RpdmVUeXBlKSB8fFxuICAgICAgICBuYXZpZ2F0b3JDb25uZWN0aW9uLnNhdmVEYXRhKTtcblxudmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihrZXkpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBkZXBlbmRlbmNpZXMgbm90IHJlYWR5XG4gICAgICAgICAgICBrZXkgPSAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgYXJncyA9IFtdLmNvbmNhdChrZXkpO1xuICAgIC8vIElmIGtleSBpcyBub3QgZmFsc3ksIG9yIG5vdCBhbiBlbXB0eSBhcnJheSwgaGFzaCBpdC5cbiAgICBrZXkgPVxuICAgICAgICB0eXBlb2Yga2V5ID09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IGtleVxuICAgICAgICAgICAgOiAoQXJyYXkuaXNBcnJheShrZXkpID8ga2V5Lmxlbmd0aCA6IGtleSlcbiAgICAgICAgICAgICAgICA/IHN0YWJsZUhhc2goa2V5KVxuICAgICAgICAgICAgICAgIDogJyc7XG4gICAgdmFyIGluZm9LZXkgPSBrZXkgPyAnJHN3ciQnICsga2V5IDogJyc7XG4gICAgcmV0dXJuIFtrZXksIGFyZ3MsIGluZm9LZXldO1xufTtcblxuLy8gR2xvYmFsIHN0YXRlIHVzZWQgdG8gZGVkdXBsaWNhdGUgcmVxdWVzdHMgYW5kIHN0b3JlIGxpc3RlbmVyc1xudmFyIFNXUkdsb2JhbFN0YXRlID0gbmV3IFdlYWtNYXAoKTtcblxudmFyIEZPQ1VTX0VWRU5UID0gMDtcbnZhciBSRUNPTk5FQ1RfRVZFTlQgPSAxO1xudmFyIE1VVEFURV9FVkVOVCA9IDI7XG5cbnZhciBicm9hZGNhc3RTdGF0ZSA9IGZ1bmN0aW9uIChjYWNoZSwga2V5LCBkYXRhLCBlcnJvciwgaXNWYWxpZGF0aW5nLCByZXZhbGlkYXRlLCBicm9hZGNhc3QpIHtcbiAgICBpZiAoYnJvYWRjYXN0ID09PSB2b2lkIDApIHsgYnJvYWRjYXN0ID0gdHJ1ZTsgfVxuICAgIHZhciBfYSA9IFNXUkdsb2JhbFN0YXRlLmdldChjYWNoZSksIEVWRU5UX1JFVkFMSURBVE9SUyA9IF9hWzBdLCBTVEFURV9VUERBVEVSUyA9IF9hWzFdLCBGRVRDSCA9IF9hWzNdO1xuICAgIHZhciByZXZhbGlkYXRvcnMgPSBFVkVOVF9SRVZBTElEQVRPUlNba2V5XTtcbiAgICB2YXIgdXBkYXRlcnMgPSBTVEFURV9VUERBVEVSU1trZXldO1xuICAgIC8vIENhY2hlIHdhcyBwb3B1bGF0ZWQsIHVwZGF0ZSBzdGF0ZXMgb2YgYWxsIGhvb2tzLlxuICAgIGlmIChicm9hZGNhc3QgJiYgdXBkYXRlcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdXBkYXRlcnNbaV0oZGF0YSwgZXJyb3IsIGlzVmFsaWRhdGluZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgd2UgYWxzbyBuZWVkIHRvIHJldmFsaWRhdGUsIG9ubHkgZG8gaXQgZm9yIHRoZSBmaXJzdCBob29rLlxuICAgIGlmIChyZXZhbGlkYXRlKSB7XG4gICAgICAgIC8vIEludmFsaWRhdGUgdGhlIGtleSBieSBkZWxldGluZyB0aGUgY29uY3VycmVudCByZXF1ZXN0IG1hcmtlcnMgc28gbmV3XG4gICAgICAgIC8vIHJlcXVlc3RzIHdpbGwgbm90IGJlIGRlZHVwZWQuXG4gICAgICAgIGRlbGV0ZSBGRVRDSFtrZXldO1xuICAgICAgICBpZiAocmV2YWxpZGF0b3JzICYmIHJldmFsaWRhdG9yc1swXSkge1xuICAgICAgICAgICAgcmV0dXJuIHJldmFsaWRhdG9yc1swXShNVVRBVEVfRVZFTlQpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbn07XG5cbi8vIEdsb2JhbCB0aW1lc3RhbXAuXG52YXIgX190aW1lc3RhbXAgPSAwO1xudmFyIGdldFRpbWVzdGFtcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICsrX190aW1lc3RhbXA7IH07XG5cbnZhciBpbnRlcm5hbE11dGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYWNoZSwgX2tleSwgX2RhdGEsIF9vcHRzLCBvcHRpb25zLCBwb3B1bGF0ZUNhY2hlLCByZXZhbGlkYXRlLCByb2xsYmFja09uRXJyb3IsIGN1c3RvbU9wdGltaXN0aWNEYXRhLCBfYSwga2V5LCBrZXlJbmZvLCBfYiwgTVVUQVRJT04sIGRhdGEsIGVycm9yLCBiZWZvcmVNdXRhdGlvblRzLCBoYXNDdXN0b21PcHRpbWlzdGljRGF0YSwgcm9sbGJhY2tEYXRhLCBvcHRpbWlzdGljRGF0YSwgcmVzO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBjYWNoZSA9IGFyZ3NbMF0sIF9rZXkgPSBhcmdzWzFdLCBfZGF0YSA9IGFyZ3NbMl0sIF9vcHRzID0gYXJnc1szXTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBfb3B0cyA9PT0gJ2Jvb2xlYW4nID8geyByZXZhbGlkYXRlOiBfb3B0cyB9IDogX29wdHMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIHBvcHVsYXRlQ2FjaGUgPSBpc1VuZGVmaW5lZChvcHRpb25zLnBvcHVsYXRlQ2FjaGUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogb3B0aW9ucy5wb3B1bGF0ZUNhY2hlO1xuICAgICAgICAgICAgICAgICAgICByZXZhbGlkYXRlID0gb3B0aW9ucy5yZXZhbGlkYXRlICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcm9sbGJhY2tPbkVycm9yID0gb3B0aW9ucy5yb2xsYmFja09uRXJyb3IgIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21PcHRpbWlzdGljRGF0YSA9IG9wdGlvbnMub3B0aW1pc3RpY0RhdGE7XG4gICAgICAgICAgICAgICAgICAgIF9hID0gc2VyaWFsaXplKF9rZXkpLCBrZXkgPSBfYVswXSwga2V5SW5mbyA9IF9hWzJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgX2IgPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpLCBNVVRBVElPTiA9IF9iWzJdO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBuZXcgZGF0YSBwcm92aWRlZCwgcmV2YWxpZGF0ZSB0aGUga2V5IHdpdGggY3VycmVudCBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2YWxpZGF0ZSBhbmQgYnJvYWRjYXN0IHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJyb2FkY2FzdFN0YXRlKGNhY2hlLCBrZXksIGNhY2hlLmdldChrZXkpLCBVTkRFRklORUQsIFVOREVGSU5FRCwgcmV2YWxpZGF0ZSwgdHJ1ZSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlTXV0YXRpb25UcyA9IGdldFRpbWVzdGFtcCgpO1xuICAgICAgICAgICAgICAgICAgICBNVVRBVElPTltrZXldID0gW2JlZm9yZU11dGF0aW9uVHMsIDBdO1xuICAgICAgICAgICAgICAgICAgICBoYXNDdXN0b21PcHRpbWlzdGljRGF0YSA9ICFpc1VuZGVmaW5lZChjdXN0b21PcHRpbWlzdGljRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJvbGxiYWNrRGF0YSA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBEbyBvcHRpbWlzdGljIGRhdGEgdXBkYXRlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQ3VzdG9tT3B0aW1pc3RpY0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWNEYXRhID0gaXNGdW5jdGlvbihjdXN0b21PcHRpbWlzdGljRGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGN1c3RvbU9wdGltaXN0aWNEYXRhKHJvbGxiYWNrRGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGN1c3RvbU9wdGltaXN0aWNEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleSwgb3B0aW1pc3RpY0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0U3RhdGUoY2FjaGUsIGtleSwgb3B0aW1pc3RpY0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgZGF0YWAgaXMgYSBmdW5jdGlvbiwgY2FsbCBpdCBwYXNzaW5nIGN1cnJlbnQgY2FjaGUgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhKGNhY2hlLmdldChrZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCB0aHJvd3MgYW4gZXJyb3Igc3luY2hyb25vdXNseSwgd2Ugc2hvdWxkbid0IHVwZGF0ZSB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGF0YSAmJiBpc0Z1bmN0aW9uKGRhdGEudGhlbikpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZGF0YS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgb3RoZXIgbXV0YXRpb25zIGhhdmUgb2NjdXJyZWQgc2luY2Ugd2UndmUgc3RhcnRlZCB0aGlzIG11dGF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHJhY2Ugd2UgZG9uJ3QgdXBkYXRlIGNhY2hlIG9yIGJyb2FkY2FzdCB0aGUgY2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCByZXR1cm4gdGhlIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHRoYXQgdGhlIG11dGF0aW9uIGlzIGFzeW5jLCB3ZSBuZWVkIHRvIGNoZWNrIHRpbWVzdGFtcHMgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gYXZvaWQgcmFjZSBjb25kaXRpb25zLlxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBvdGhlciBtdXRhdGlvbnMgaGF2ZSBvY2N1cnJlZCBzaW5jZSB3ZSd2ZSBzdGFydGVkIHRoaXMgbXV0YXRpb24uXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSByYWNlIHdlIGRvbid0IHVwZGF0ZSBjYWNoZSBvciBicm9hZGNhc3QgdGhlIGNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgLy8ganVzdCByZXR1cm4gdGhlIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmVNdXRhdGlvblRzICE9PSBNVVRBVElPTltrZXldWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGF0YV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgJiYgaGFzQ3VzdG9tT3B0aW1pc3RpY0RhdGEgJiYgcm9sbGJhY2tPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSb2xsYmFjay4gQWx3YXlzIHBvcHVsYXRlIHRoZSBjYWNoZSBpbiB0aGlzIGNhc2UgYnV0IHdpdGhvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybWluZyB0aGUgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcHVsYXRlQ2FjaGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHJvbGxiYWNrRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnNldChrZXksIHJvbGxiYWNrRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2Ugc2hvdWxkIHdyaXRlIGJhY2sgdGhlIGNhY2hlIGFmdGVyIHJlcXVlc3QuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3B1bGF0ZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHRoZSByZXN1bHQgaW50byBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHBvcHVsYXRlQ2FjaGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwb3B1bGF0ZUNhY2hlKGRhdGEsIHJvbGxiYWNrRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIGNhY2hlZCBkYXRhIGlmIHRoZXJlJ3Mgbm8gZXJyb3IuIERhdGEgY2FuIGJlIGB1bmRlZmluZWRgIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHdheXMgdXBkYXRlIG9yIHJlc2V0IHRoZSBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnNldChrZXlJbmZvLCBtZXJnZU9iamVjdHMoY2FjaGUuZ2V0KGtleUluZm8pLCB7IGVycm9yOiBlcnJvciB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHRpbWVzdGFtcCB0byBtYXJrIHRoZSBtdXRhdGlvbiBoYXMgZW5kZWQuXG4gICAgICAgICAgICAgICAgICAgIE1VVEFUSU9OW2tleV1bMV0gPSBnZXRUaW1lc3RhbXAoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYnJvYWRjYXN0U3RhdGUoY2FjaGUsIGtleSwgZGF0YSwgZXJyb3IsIFVOREVGSU5FRCwgcmV2YWxpZGF0ZSwgISFwb3B1bGF0ZUNhY2hlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhyb3cgZXJyb3Igb3IgcmV0dXJuIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhyb3cgZXJyb3Igb3IgcmV0dXJuIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBwb3B1bGF0ZUNhY2hlID8gcmVzIDogZGF0YV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxudmFyIHJldmFsaWRhdGVBbGxLZXlzID0gZnVuY3Rpb24gKHJldmFsaWRhdG9ycywgdHlwZSkge1xuICAgIGZvciAodmFyIGtleSBpbiByZXZhbGlkYXRvcnMpIHtcbiAgICAgICAgaWYgKHJldmFsaWRhdG9yc1trZXldWzBdKVxuICAgICAgICAgICAgcmV2YWxpZGF0b3JzW2tleV1bMF0odHlwZSk7XG4gICAgfVxufTtcbnZhciBpbml0Q2FjaGUgPSBmdW5jdGlvbiAocHJvdmlkZXIsIG9wdGlvbnMpIHtcbiAgICAvLyBUaGUgZ2xvYmFsIHN0YXRlIGZvciBhIHNwZWNpZmljIHByb3ZpZGVyIHdpbGwgYmUgdXNlZCB0byBkZWR1cGxpY2F0ZVxuICAgIC8vIHJlcXVlc3RzIGFuZCBzdG9yZSBsaXN0ZW5lcnMuIEFzIHdlbGwgYXMgYSBtdXRhdGUgZnVuY3Rpb24gdGhhdCBib3VuZCB0b1xuICAgIC8vIHRoZSBjYWNoZS5cbiAgICAvLyBQcm92aWRlcidzIGdsb2JhbCBzdGF0ZSBtaWdodCBiZSBhbHJlYWR5IGluaXRpYWxpemVkLiBMZXQncyB0cnkgdG8gZ2V0IHRoZVxuICAgIC8vIGdsb2JhbCBzdGF0ZSBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVyIGZpcnN0LlxuICAgIGlmICghU1dSR2xvYmFsU3RhdGUuaGFzKHByb3ZpZGVyKSkge1xuICAgICAgICB2YXIgb3B0cyA9IG1lcmdlT2JqZWN0cyhkZWZhdWx0Q29uZmlnT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZ2xvYmFsIHN0YXRlIGJvdW5kIHRvIHRoZSBwcm92aWRlciwgY3JlYXRlIGEgbmV3IG9uZSB3aXRoIHRoZVxuICAgICAgICAvLyBuZXcgbXV0YXRlIGZ1bmN0aW9uLlxuICAgICAgICB2YXIgRVZFTlRfUkVWQUxJREFUT1JTID0ge307XG4gICAgICAgIHZhciBtdXRhdGUgPSBpbnRlcm5hbE11dGF0ZS5iaW5kKFVOREVGSU5FRCwgcHJvdmlkZXIpO1xuICAgICAgICB2YXIgdW5tb3VudCA9IG5vb3A7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc3RhdGUgaWYgaXQncyBuZXcsIG9yIHRoZSBwcm92aWRlciBoYXMgYmVlbiBleHRlbmRlZC5cbiAgICAgICAgU1dSR2xvYmFsU3RhdGUuc2V0KHByb3ZpZGVyLCBbRVZFTlRfUkVWQUxJREFUT1JTLCB7fSwge30sIHt9LCBtdXRhdGVdKTtcbiAgICAgICAgLy8gVGhpcyBpcyBhIG5ldyBwcm92aWRlciwgd2UgbmVlZCB0byBpbml0aWFsaXplIGl0IGFuZCBzZXR1cCBET00gZXZlbnRzXG4gICAgICAgIC8vIGxpc3RlbmVycyBmb3IgYGZvY3VzYCBhbmQgYHJlY29ubmVjdGAgYWN0aW9ucy5cbiAgICAgICAgaWYgKCFJU19TRVJWRVIpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gbGlzdGVuaW5nIHRvIHRoZSBuYXRpdmUgZXZlbnRzIGZvciBhdXRvIHJldmFsaWRhdGlvbnMsXG4gICAgICAgICAgICAvLyB3ZSBpbnRlbnRpb25hbGx5IHB1dCBhIGRlbGF5IChzZXRUaW1lb3V0KSBoZXJlIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZVxuICAgICAgICAgICAgLy8gZmlyZWQgYWZ0ZXIgaW1tZWRpYXRlIEphdmFTY3JpcHQgZXhlY3V0aW9ucywgd2hpY2ggY2FuIHBvc3NpYmx5IGJlXG4gICAgICAgICAgICAvLyBSZWFjdCdzIHN0YXRlIHVwZGF0ZXMuXG4gICAgICAgICAgICAvLyBUaGlzIGF2b2lkcyBzb21lIHVubmVjZXNzYXJ5IHJldmFsaWRhdGlvbnMgc3VjaCBhc1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9zd3IvaXNzdWVzLzE2ODAuXG4gICAgICAgICAgICB2YXIgcmVsZWFzZUZvY3VzXzEgPSBvcHRzLmluaXRGb2N1cyhzZXRUaW1lb3V0LmJpbmQoVU5ERUZJTkVELCByZXZhbGlkYXRlQWxsS2V5cy5iaW5kKFVOREVGSU5FRCwgRVZFTlRfUkVWQUxJREFUT1JTLCBGT0NVU19FVkVOVCkpKTtcbiAgICAgICAgICAgIHZhciByZWxlYXNlUmVjb25uZWN0XzEgPSBvcHRzLmluaXRSZWNvbm5lY3Qoc2V0VGltZW91dC5iaW5kKFVOREVGSU5FRCwgcmV2YWxpZGF0ZUFsbEtleXMuYmluZChVTkRFRklORUQsIEVWRU5UX1JFVkFMSURBVE9SUywgUkVDT05ORUNUX0VWRU5UKSkpO1xuICAgICAgICAgICAgdW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZWxlYXNlRm9jdXNfMSAmJiByZWxlYXNlRm9jdXNfMSgpO1xuICAgICAgICAgICAgICAgIHJlbGVhc2VSZWNvbm5lY3RfMSAmJiByZWxlYXNlUmVjb25uZWN0XzEoKTtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHVuLW1vdW50aW5nLCB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgY2FjaGUgcHJvdmlkZXIgZnJvbSB0aGUgc3RhdGVcbiAgICAgICAgICAgICAgICAvLyBzdG9yYWdlIHRvbyBiZWNhdXNlIGl0J3MgYSBzaWRlLWVmZmVjdC4gT3RoZXJ3aXNlIHdoZW4gcmUtbW91bnRpbmcgd2VcbiAgICAgICAgICAgICAgICAvLyB3aWxsIG5vdCByZS1yZWdpc3RlciB0aG9zZSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgICAgICAgICAgU1dSR2xvYmFsU3RhdGUuZGVsZXRlKHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgbWlnaHQgd2FudCB0byBpbmplY3QgYW4gZXh0cmEgbGF5ZXIgb24gdG9wIG9mIGBwcm92aWRlcmAgaW4gdGhlIGZ1dHVyZSxcbiAgICAgICAgLy8gc3VjaCBhcyBrZXkgc2VyaWFsaXphdGlvbiwgYXV0byBHQywgZXRjLlxuICAgICAgICAvLyBGb3Igbm93LCBpdCdzIGp1c3QgYSBgTWFwYCBpbnRlcmZhY2Ugd2l0aG91dCBhbnkgbW9kaWZpY2F0aW9ucy5cbiAgICAgICAgcmV0dXJuIFtwcm92aWRlciwgbXV0YXRlLCB1bm1vdW50XTtcbiAgICB9XG4gICAgcmV0dXJuIFtwcm92aWRlciwgU1dSR2xvYmFsU3RhdGUuZ2V0KHByb3ZpZGVyKVs0XV07XG59O1xuXG4vLyBlcnJvciByZXRyeVxudmFyIG9uRXJyb3JSZXRyeSA9IGZ1bmN0aW9uIChfLCBfXywgY29uZmlnLCByZXZhbGlkYXRlLCBvcHRzKSB7XG4gICAgdmFyIG1heFJldHJ5Q291bnQgPSBjb25maWcuZXJyb3JSZXRyeUNvdW50O1xuICAgIHZhciBjdXJyZW50UmV0cnlDb3VudCA9IG9wdHMucmV0cnlDb3VudDtcbiAgICAvLyBFeHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgdmFyIHRpbWVvdXQgPSB+figoTWF0aC5yYW5kb20oKSArIDAuNSkgKlxuICAgICAgICAoMSA8PCAoY3VycmVudFJldHJ5Q291bnQgPCA4ID8gY3VycmVudFJldHJ5Q291bnQgOiA4KSkpICogY29uZmlnLmVycm9yUmV0cnlJbnRlcnZhbDtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKG1heFJldHJ5Q291bnQpICYmIGN1cnJlbnRSZXRyeUNvdW50ID4gbWF4UmV0cnlDb3VudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldFRpbWVvdXQocmV2YWxpZGF0ZSwgdGltZW91dCwgb3B0cyk7XG59O1xuLy8gRGVmYXVsdCBjYWNoZSBwcm92aWRlclxudmFyIF9hID0gaW5pdENhY2hlKG5ldyBNYXAoKSksIGNhY2hlID0gX2FbMF0sIG11dGF0ZSA9IF9hWzFdO1xuLy8gRGVmYXVsdCBjb25maWdcbnZhciBkZWZhdWx0Q29uZmlnID0gbWVyZ2VPYmplY3RzKHtcbiAgICAvLyBldmVudHNcbiAgICBvbkxvYWRpbmdTbG93OiBub29wLFxuICAgIG9uU3VjY2Vzczogbm9vcCxcbiAgICBvbkVycm9yOiBub29wLFxuICAgIG9uRXJyb3JSZXRyeTogb25FcnJvclJldHJ5LFxuICAgIG9uRGlzY2FyZGVkOiBub29wLFxuICAgIC8vIHN3aXRjaGVzXG4gICAgcmV2YWxpZGF0ZU9uRm9jdXM6IHRydWUsXG4gICAgcmV2YWxpZGF0ZU9uUmVjb25uZWN0OiB0cnVlLFxuICAgIHJldmFsaWRhdGVJZlN0YWxlOiB0cnVlLFxuICAgIHNob3VsZFJldHJ5T25FcnJvcjogdHJ1ZSxcbiAgICAvLyB0aW1lb3V0c1xuICAgIGVycm9yUmV0cnlJbnRlcnZhbDogc2xvd0Nvbm5lY3Rpb24gPyAxMDAwMCA6IDUwMDAsXG4gICAgZm9jdXNUaHJvdHRsZUludGVydmFsOiA1ICogMTAwMCxcbiAgICBkZWR1cGluZ0ludGVydmFsOiAyICogMTAwMCxcbiAgICBsb2FkaW5nVGltZW91dDogc2xvd0Nvbm5lY3Rpb24gPyA1MDAwIDogMzAwMCxcbiAgICAvLyBwcm92aWRlcnNcbiAgICBjb21wYXJlOiBmdW5jdGlvbiAoY3VycmVudERhdGEsIG5ld0RhdGEpIHtcbiAgICAgICAgcmV0dXJuIHN0YWJsZUhhc2goY3VycmVudERhdGEpID09IHN0YWJsZUhhc2gobmV3RGF0YSk7XG4gICAgfSxcbiAgICBpc1BhdXNlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgY2FjaGU6IGNhY2hlLFxuICAgIG11dGF0ZTogbXV0YXRlLFxuICAgIGZhbGxiYWNrOiB7fVxufSwgXG4vLyB1c2Ugd2ViIHByZXNldCBieSBkZWZhdWx0XG5wcmVzZXQpO1xuXG52YXIgbWVyZ2VDb25maWdzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAvLyBOZWVkIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3QgdG8gYXZvaWQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsIGhlcmUuXG4gICAgdmFyIHYgPSBtZXJnZU9iamVjdHMoYSwgYik7XG4gICAgLy8gSWYgdHdvIGNvbmZpZ3MgYXJlIHByb3ZpZGVkLCBtZXJnZSB0aGVpciBgdXNlYCBhbmQgYGZhbGxiYWNrYCBvcHRpb25zLlxuICAgIGlmIChiKSB7XG4gICAgICAgIHZhciB1MSA9IGEudXNlLCBmMSA9IGEuZmFsbGJhY2s7XG4gICAgICAgIHZhciB1MiA9IGIudXNlLCBmMiA9IGIuZmFsbGJhY2s7XG4gICAgICAgIGlmICh1MSAmJiB1Mikge1xuICAgICAgICAgICAgdi51c2UgPSB1MS5jb25jYXQodTIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmMSAmJiBmMikge1xuICAgICAgICAgICAgdi5mYWxsYmFjayA9IG1lcmdlT2JqZWN0cyhmMSwgZjIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2O1xufTtcblxudmFyIFNXUkNvbmZpZ0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcbnZhciBTV1JDb25maWckMSA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgIC8vIEV4dGVuZCBwYXJlbnQgY29udGV4dCB2YWx1ZXMgYW5kIG1pZGRsZXdhcmUuXG4gICAgdmFyIGV4dGVuZGVkQ29uZmlnID0gbWVyZ2VDb25maWdzKHVzZUNvbnRleHQoU1dSQ29uZmlnQ29udGV4dCksIHZhbHVlKTtcbiAgICAvLyBTaG91bGQgbm90IHVzZSB0aGUgaW5oZXJpdGVkIHByb3ZpZGVyLlxuICAgIHZhciBwcm92aWRlciA9IHZhbHVlICYmIHZhbHVlLnByb3ZpZGVyO1xuICAgIC8vIFVzZSBhIGxhenkgaW5pdGlhbGl6ZWQgc3RhdGUgdG8gY3JlYXRlIHRoZSBjYWNoZSBvbiBmaXJzdCBhY2Nlc3MuXG4gICAgdmFyIGNhY2hlQ29udGV4dCA9IHVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyXG4gICAgICAgICAgICA/IGluaXRDYWNoZShwcm92aWRlcihleHRlbmRlZENvbmZpZy5jYWNoZSB8fCBjYWNoZSksIHZhbHVlKVxuICAgICAgICAgICAgOiBVTkRFRklORUQ7XG4gICAgfSlbMF07XG4gICAgLy8gT3ZlcnJpZGUgdGhlIGNhY2hlIGlmIGEgbmV3IHByb3ZpZGVyIGlzIGdpdmVuLlxuICAgIGlmIChjYWNoZUNvbnRleHQpIHtcbiAgICAgICAgZXh0ZW5kZWRDb25maWcuY2FjaGUgPSBjYWNoZUNvbnRleHRbMF07XG4gICAgICAgIGV4dGVuZGVkQ29uZmlnLm11dGF0ZSA9IGNhY2hlQ29udGV4dFsxXTtcbiAgICB9XG4gICAgLy8gVW5zdWJzY3JpYmUgZXZlbnRzLlxuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gKGNhY2hlQ29udGV4dCA/IGNhY2hlQ29udGV4dFsyXSA6IFVOREVGSU5FRCk7IH0sIFtdKTtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChTV1JDb25maWdDb250ZXh0LlByb3ZpZGVyLCBtZXJnZU9iamVjdHMocHJvcHMsIHtcbiAgICAgICAgdmFsdWU6IGV4dGVuZGVkQ29uZmlnXG4gICAgfSkpO1xufTtcblxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBzdGF0ZSB3aXRoIGRlcGVuZGVuY3ktdHJhY2tpbmcuXG4gKi9cbnZhciB1c2VTdGF0ZVdpdGhEZXBzID0gZnVuY3Rpb24gKHN0YXRlLCB1bm1vdW50ZWRSZWYpIHtcbiAgICB2YXIgcmVyZW5kZXIgPSB1c2VTdGF0ZSh7fSlbMV07XG4gICAgdmFyIHN0YXRlUmVmID0gdXNlUmVmKHN0YXRlKTtcbiAgICAvLyBJZiBhIHN0YXRlIHByb3BlcnR5IChkYXRhLCBlcnJvciBvciBpc1ZhbGlkYXRpbmcpIGlzIGFjY2Vzc2VkIGJ5IHRoZSByZW5kZXJcbiAgICAvLyBmdW5jdGlvbiwgd2UgbWFyayB0aGUgcHJvcGVydHkgYXMgYSBkZXBlbmRlbmN5IHNvIGlmIGl0IGlzIHVwZGF0ZWQgYWdhaW5cbiAgICAvLyBpbiB0aGUgZnV0dXJlLCB3ZSB0cmlnZ2VyIGEgcmVyZW5kZXIuXG4gICAgLy8gVGhpcyBpcyBhbHNvIGtub3duIGFzIGRlcGVuZGVuY3ktdHJhY2tpbmcuXG4gICAgdmFyIHN0YXRlRGVwZW5kZW5jaWVzUmVmID0gdXNlUmVmKHtcbiAgICAgICAgZGF0YTogZmFsc2UsXG4gICAgICAgIGVycm9yOiBmYWxzZSxcbiAgICAgICAgaXNWYWxpZGF0aW5nOiBmYWxzZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFRvIGNoYW5nZSBzdGF0ZVJlZiwgcGFzcyB0aGUgdmFsdWVzIGV4cGxpY2l0bHkgdG8gc2V0U3RhdGU6XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIHNldFN0YXRlKHtcbiAgICAgKiAgIGlzVmFsaWRhdGluZzogZmFsc2VcbiAgICAgKiAgIGRhdGE6IG5ld0RhdGEgLy8gc2V0IGRhdGEgdG8gbmV3RGF0YVxuICAgICAqICAgZXJyb3I6IHVuZGVmaW5lZCAvLyBzZXQgZXJyb3IgdG8gdW5kZWZpbmVkXG4gICAgICogfSlcbiAgICAgKlxuICAgICAqIHNldFN0YXRlKHtcbiAgICAgKiAgIGlzVmFsaWRhdGluZzogZmFsc2VcbiAgICAgKiAgIGRhdGE6IHVuZGVmaW5lZCAvLyBzZXQgZGF0YSB0byB1bmRlZmluZWRcbiAgICAgKiAgIGVycm9yOiBlcnIgLy8gc2V0IGVycm9yIHRvIGVyclxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgdmFyIHNldFN0YXRlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIHNob3VsZFJlcmVuZGVyID0gZmFsc2U7XG4gICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBzdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgICBmb3IgKHZhciBfIGluIHBheWxvYWQpIHtcbiAgICAgICAgICAgIHZhciBrID0gXztcbiAgICAgICAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBoYXMgY2hhbmdlZCwgdXBkYXRlIHRoZSBzdGF0ZSBhbmQgbWFyayByZXJlbmRlciBhc1xuICAgICAgICAgICAgLy8gbmVlZGVkLlxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZVtrXSAhPT0gcGF5bG9hZFtrXSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZVtrXSA9IHBheWxvYWRba107XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHByb3BlcnR5IGlzIGFjY2Vzc2VkIGJ5IHRoZSBjb21wb25lbnQsIGEgcmVyZW5kZXIgc2hvdWxkIGJlXG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlcmVkLlxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZURlcGVuZGVuY2llc1JlZi5jdXJyZW50W2tdKSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFJlcmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFJlcmVuZGVyICYmICF1bm1vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgcmVyZW5kZXIoe30pO1xuICAgICAgICB9XG4gICAgfSwgXG4gICAgLy8gY29uZmlnLnN1c3BlbnNlIGlzbid0IGFsbG93ZWQgdG8gY2hhbmdlIGR1cmluZyB0aGUgbGlmZWN5Y2xlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtdKTtcbiAgICAvLyBBbHdheXMgdXBkYXRlIHRoZSBzdGF0ZSByZWZlcmVuY2UuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0YXRlUmVmLmN1cnJlbnQgPSBzdGF0ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gW3N0YXRlUmVmLCBzdGF0ZURlcGVuZGVuY2llc1JlZi5jdXJyZW50LCBzZXRTdGF0ZV07XG59O1xuXG52YXIgbm9ybWFsaXplID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihhcmdzWzFdKVxuICAgICAgICA/IFthcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdIHx8IHt9XVxuICAgICAgICA6IFthcmdzWzBdLCBudWxsLCAoYXJnc1sxXSA9PT0gbnVsbCA/IGFyZ3NbMl0gOiBhcmdzWzFdKSB8fCB7fV07XG59O1xuXG52YXIgdXNlU1dSQ29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBtZXJnZU9iamVjdHMoZGVmYXVsdENvbmZpZywgdXNlQ29udGV4dChTV1JDb25maWdDb250ZXh0KSk7XG59O1xuXG4vLyBJdCdzIHRyaWNreSB0byBwYXNzIGdlbmVyaWMgdHlwZXMgYXMgcGFyYW1ldGVycywgc28gd2UganVzdCBkaXJlY3RseSBvdmVycmlkZVxuLy8gdGhlIHR5cGVzIGhlcmUuXG52YXIgd2l0aEFyZ3MgPSBmdW5jdGlvbiAoaG9vaykge1xuICAgIHJldHVybiBmdW5jdGlvbiB1c2VTV1JBcmdzKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB0aGUgZGVmYXVsdCBhbmQgaW5oZXJpdGVkIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgIHZhciBmYWxsYmFja0NvbmZpZyA9IHVzZVNXUkNvbmZpZygpO1xuICAgICAgICAvLyBOb3JtYWxpemUgYXJndW1lbnRzLlxuICAgICAgICB2YXIgX2EgPSBub3JtYWxpemUoYXJncyksIGtleSA9IF9hWzBdLCBmbiA9IF9hWzFdLCBfY29uZmlnID0gX2FbMl07XG4gICAgICAgIC8vIE1lcmdlIGNvbmZpZ3VyYXRpb25zLlxuICAgICAgICB2YXIgY29uZmlnID0gbWVyZ2VDb25maWdzKGZhbGxiYWNrQ29uZmlnLCBfY29uZmlnKTtcbiAgICAgICAgLy8gQXBwbHkgbWlkZGxld2FyZVxuICAgICAgICB2YXIgbmV4dCA9IGhvb2s7XG4gICAgICAgIHZhciB1c2UgPSBjb25maWcudXNlO1xuICAgICAgICBpZiAodXNlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdXNlLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gdXNlW2ldKG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0KGtleSwgZm4gfHwgY29uZmlnLmZldGNoZXIsIGNvbmZpZyk7XG4gICAgfTtcbn07XG5cbi8vIEFkZCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGEgbGlzdCBvZiBrZXllZCBjYWxsYmFjayBmdW5jdGlvbnMgYW5kIHJldHVyblxuLy8gdGhlIHVuc3Vic2NyaWJlIGZ1bmN0aW9uLlxudmFyIHN1YnNjcmliZUNhbGxiYWNrID0gZnVuY3Rpb24gKGtleSwgY2FsbGJhY2tzLCBjYWxsYmFjaykge1xuICAgIHZhciBrZXllZFJldmFsaWRhdG9ycyA9IGNhbGxiYWNrc1trZXldIHx8IChjYWxsYmFja3Nba2V5XSA9IFtdKTtcbiAgICBrZXllZFJldmFsaWRhdG9ycy5wdXNoKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5kZXggPSBrZXllZFJldmFsaWRhdG9ycy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIC8vIE8oMSk6IGZhc3RlciB0aGFuIHNwbGljZVxuICAgICAgICAgICAga2V5ZWRSZXZhbGlkYXRvcnNbaW5kZXhdID0ga2V5ZWRSZXZhbGlkYXRvcnNba2V5ZWRSZXZhbGlkYXRvcnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBrZXllZFJldmFsaWRhdG9ycy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG52YXIgV0lUSF9ERURVUEUgPSB7IGRlZHVwZTogdHJ1ZSB9O1xudmFyIHVzZVNXUkhhbmRsZXIgPSBmdW5jdGlvbiAoX2tleSwgZmV0Y2hlciwgY29uZmlnKSB7XG4gICAgdmFyIGNhY2hlID0gY29uZmlnLmNhY2hlLCBjb21wYXJlID0gY29uZmlnLmNvbXBhcmUsIGZhbGxiYWNrRGF0YSA9IGNvbmZpZy5mYWxsYmFja0RhdGEsIHN1c3BlbnNlID0gY29uZmlnLnN1c3BlbnNlLCByZXZhbGlkYXRlT25Nb3VudCA9IGNvbmZpZy5yZXZhbGlkYXRlT25Nb3VudCwgcmVmcmVzaEludGVydmFsID0gY29uZmlnLnJlZnJlc2hJbnRlcnZhbCwgcmVmcmVzaFdoZW5IaWRkZW4gPSBjb25maWcucmVmcmVzaFdoZW5IaWRkZW4sIHJlZnJlc2hXaGVuT2ZmbGluZSA9IGNvbmZpZy5yZWZyZXNoV2hlbk9mZmxpbmU7XG4gICAgdmFyIF9hID0gU1dSR2xvYmFsU3RhdGUuZ2V0KGNhY2hlKSwgRVZFTlRfUkVWQUxJREFUT1JTID0gX2FbMF0sIFNUQVRFX1VQREFURVJTID0gX2FbMV0sIE1VVEFUSU9OID0gX2FbMl0sIEZFVENIID0gX2FbM107XG4gICAgLy8gYGtleWAgaXMgdGhlIGlkZW50aWZpZXIgb2YgdGhlIFNXUiBgZGF0YWAgc3RhdGUsIGBrZXlJbmZvYCBob2xkcyBleHRyYVxuICAgIC8vIHN0YXRlcyBzdWNoIGFzIGBlcnJvcmAgYW5kIGBpc1ZhbGlkYXRpbmdgIGluc2lkZSxcbiAgICAvLyBhbGwgb2YgdGhlbSBhcmUgZGVyaXZlZCBmcm9tIGBfa2V5YC5cbiAgICAvLyBgZm5BcmdzYCBpcyBhbiBhcnJheSBvZiBhcmd1bWVudHMgcGFyc2VkIGZyb20gdGhlIGtleSwgd2hpY2ggd2lsbCBiZSBwYXNzZWRcbiAgICAvLyB0byB0aGUgZmV0Y2hlci5cbiAgICB2YXIgX2IgPSBzZXJpYWxpemUoX2tleSksIGtleSA9IF9iWzBdLCBmbkFyZ3MgPSBfYlsxXSwga2V5SW5mbyA9IF9iWzJdO1xuICAgIC8vIElmIGl0J3MgdGhlIGluaXRpYWwgcmVuZGVyIG9mIHRoaXMgaG9vay5cbiAgICB2YXIgaW5pdGlhbE1vdW50ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIC8vIElmIHRoZSBob29rIGlzIHVubW91bnRlZCBhbHJlYWR5LiBUaGlzIHdpbGwgYmUgdXNlZCB0byBwcmV2ZW50IHNvbWUgZWZmZWN0c1xuICAgIC8vIHRvIGJlIGNhbGxlZCBhZnRlciB1bm1vdW50aW5nLlxuICAgIHZhciB1bm1vdW50ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIC8vIFJlZnMgdG8ga2VlcCB0aGUga2V5IGFuZCBjb25maWcuXG4gICAgdmFyIGtleVJlZiA9IHVzZVJlZihrZXkpO1xuICAgIHZhciBmZXRjaGVyUmVmID0gdXNlUmVmKGZldGNoZXIpO1xuICAgIHZhciBjb25maWdSZWYgPSB1c2VSZWYoY29uZmlnKTtcbiAgICB2YXIgZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnUmVmLmN1cnJlbnQ7IH07XG4gICAgdmFyIGlzQWN0aXZlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0Q29uZmlnKCkuaXNWaXNpYmxlKCkgJiYgZ2V0Q29uZmlnKCkuaXNPbmxpbmUoKTsgfTtcbiAgICB2YXIgcGF0Y2hGZXRjaEluZm8gPSBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICByZXR1cm4gY2FjaGUuc2V0KGtleUluZm8sIG1lcmdlT2JqZWN0cyhjYWNoZS5nZXQoa2V5SW5mbyksIGluZm8pKTtcbiAgICB9O1xuICAgIC8vIEdldCB0aGUgY3VycmVudCBzdGF0ZSB0aGF0IFNXUiBzaG91bGQgcmV0dXJuLlxuICAgIHZhciBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICB2YXIgZmFsbGJhY2sgPSBpc1VuZGVmaW5lZChmYWxsYmFja0RhdGEpXG4gICAgICAgID8gY29uZmlnLmZhbGxiYWNrW2tleV1cbiAgICAgICAgOiBmYWxsYmFja0RhdGE7XG4gICAgdmFyIGRhdGEgPSBpc1VuZGVmaW5lZChjYWNoZWQpID8gZmFsbGJhY2sgOiBjYWNoZWQ7XG4gICAgdmFyIGluZm8gPSBjYWNoZS5nZXQoa2V5SW5mbykgfHwge307XG4gICAgdmFyIGVycm9yID0gaW5mby5lcnJvcjtcbiAgICB2YXIgaXNJbml0aWFsTW91bnQgPSAhaW5pdGlhbE1vdW50ZWRSZWYuY3VycmVudDtcbiAgICAvLyAtIFN1c3BlbnNlIG1vZGUgYW5kIHRoZXJlJ3Mgc3RhbGUgZGF0YSBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuICAgIC8vIC0gTm90IHN1c3BlbnNlIG1vZGUgYW5kIHRoZXJlIGlzIG5vIGZhbGxiYWNrIGRhdGEgYW5kIGByZXZhbGlkYXRlSWZTdGFsZWAgaXMgZW5hYmxlZC5cbiAgICAvLyAtIGByZXZhbGlkYXRlSWZTdGFsZWAgaXMgZW5hYmxlZCBidXQgYGRhdGFgIGlzIG5vdCBkZWZpbmVkLlxuICAgIHZhciBzaG91bGRSZXZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJZiBgcmV2YWxpZGF0ZU9uTW91bnRgIGlzIHNldCwgd2UgdGFrZSB0aGUgdmFsdWUgZGlyZWN0bHkuXG4gICAgICAgIGlmIChpc0luaXRpYWxNb3VudCAmJiAhaXNVbmRlZmluZWQocmV2YWxpZGF0ZU9uTW91bnQpKVxuICAgICAgICAgICAgcmV0dXJuIHJldmFsaWRhdGVPbk1vdW50O1xuICAgICAgICAvLyBJZiBpdCdzIHBhdXNlZCwgd2Ugc2tpcCByZXZhbGlkYXRpb24uXG4gICAgICAgIGlmIChnZXRDb25maWcoKS5pc1BhdXNlZCgpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBVbmRlciBzdXNwZW5zZSBtb2RlLCBpdCB3aWxsIGFsd2F5cyBmZXRjaCBvbiByZW5kZXIgaWYgdGhlcmUgaXMgbm9cbiAgICAgICAgLy8gc3RhbGUgZGF0YSBzbyBubyBuZWVkIHRvIHJldmFsaWRhdGUgaW1tZWRpYXRlbHkgb24gbW91bnQgYWdhaW4uXG4gICAgICAgIC8vIElmIGRhdGEgZXhpc3RzLCBvbmx5IHJldmFsaWRhdGUgaWYgYHJldmFsaWRhdGVJZlN0YWxlYCBpcyB0cnVlLlxuICAgICAgICBpZiAoc3VzcGVuc2UpXG4gICAgICAgICAgICByZXR1cm4gaXNVbmRlZmluZWQoZGF0YSkgPyBmYWxzZSA6IGNvbmZpZy5yZXZhbGlkYXRlSWZTdGFsZTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gc3RhbGUgZGF0YSwgd2UgbmVlZCB0byByZXZhbGlkYXRlIG9uIG1vdW50O1xuICAgICAgICAvLyBJZiBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIHNldCB0byB0cnVlLCB3ZSB3aWxsIGFsd2F5cyByZXZhbGlkYXRlLlxuICAgICAgICByZXR1cm4gaXNVbmRlZmluZWQoZGF0YSkgfHwgY29uZmlnLnJldmFsaWRhdGVJZlN0YWxlO1xuICAgIH07XG4gICAgLy8gUmVzb2x2ZSB0aGUgY3VycmVudCB2YWxpZGF0aW5nIHN0YXRlLlxuICAgIHZhciByZXNvbHZlVmFsaWRhdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFrZXkgfHwgIWZldGNoZXIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChpbmZvLmlzVmFsaWRhdGluZylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBJZiBpdCdzIG5vdCBtb3VudGVkIHlldCBhbmQgaXQgc2hvdWxkIHJldmFsaWRhdGUgb24gbW91bnQsIHJldmFsaWRhdGUuXG4gICAgICAgIHJldHVybiBpc0luaXRpYWxNb3VudCAmJiBzaG91bGRSZXZhbGlkYXRlKCk7XG4gICAgfTtcbiAgICB2YXIgaXNWYWxpZGF0aW5nID0gcmVzb2x2ZVZhbGlkYXRpbmcoKTtcbiAgICB2YXIgX2MgPSB1c2VTdGF0ZVdpdGhEZXBzKHtcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBpc1ZhbGlkYXRpbmc6IGlzVmFsaWRhdGluZ1xuICAgIH0sIHVubW91bnRlZFJlZiksIHN0YXRlUmVmID0gX2NbMF0sIHN0YXRlRGVwZW5kZW5jaWVzID0gX2NbMV0sIHNldFN0YXRlID0gX2NbMl07XG4gICAgLy8gVGhlIHJldmFsaWRhdGlvbiBmdW5jdGlvbiBpcyBhIGNhcmVmdWxseSBjcmFmdGVkIHdyYXBwZXIgb2YgdGhlIG9yaWdpbmFsXG4gICAgLy8gYGZldGNoZXJgLCB0byBjb3JyZWN0bHkgaGFuZGxlIHRoZSBtYW55IGVkZ2UgY2FzZXMuXG4gICAgdmFyIHJldmFsaWRhdGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAocmV2YWxpZGF0ZU9wdHMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50RmV0Y2hlciwgbmV3RGF0YSwgc3RhcnRBdCwgbG9hZGluZywgb3B0cywgc2hvdWxkU3RhcnROZXdSZXF1ZXN0LCBpc0N1cnJlbnRLZXlNb3VudGVkLCBjbGVhbnVwU3RhdGUsIG5ld1N0YXRlLCBmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUsIG11dGF0aW9uSW5mbywgZXJyXzE7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEZldGNoZXIgPSBmZXRjaGVyUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICgha2V5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhY3VycmVudEZldGNoZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVubW91bnRlZFJlZi5jdXJyZW50IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25maWcoKS5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmFsc2VdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvcHRzID0gcmV2YWxpZGF0ZU9wdHMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFN0YXJ0TmV3UmVxdWVzdCA9ICFGRVRDSFtrZXldIHx8ICFvcHRzLmRlZHVwZTtcbiAgICAgICAgICAgICAgICAgICAgaXNDdXJyZW50S2V5TW91bnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhdW5tb3VudGVkUmVmLmN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPT09IGtleVJlZi5jdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbE1vdW50ZWRSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBzdGlsbCB0aGUgc2FtZSByZXF1ZXN0IGJlZm9yZSBkZWxldGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0SW5mbyA9IEZFVENIW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdEluZm8gJiYgcmVxdWVzdEluZm9bMV0gPT09IHN0YXJ0QXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgRkVUQ0hba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB7IGlzVmFsaWRhdGluZzogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hGZXRjaEluZm8oeyBpc1ZhbGlkYXRpbmc6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIG9ubHkgc2V0IHN0YXRlIGlmIGl0J3Mgc2FmZSAoc3RpbGwgbW91bnRlZCB3aXRoIHRoZSBzYW1lIGtleSkuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50S2V5TW91bnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBmZXRjaGluZy4gQ2hhbmdlIHRoZSBgaXNWYWxpZGF0aW5nYCBzdGF0ZSwgdXBkYXRlIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hGZXRjaEluZm8oe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzZXRTdGF0ZSh7IGlzVmFsaWRhdGluZzogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGVsbCBhbGwgb3RoZXIgaG9va3MgdG8gY2hhbmdlIHRoZSBgaXNWYWxpZGF0aW5nYCBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyb2FkY2FzdFN0YXRlKGNhY2hlLCBrZXksIHN0YXRlUmVmLmN1cnJlbnQuZGF0YSwgc3RhdGVSZWYuY3VycmVudC5lcnJvciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBjYWNoZSBiZWluZyByZW5kZXJlZCBjdXJyZW50bHkgKGl0IHNob3dzIGEgYmxhbmsgcGFnZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB0cmlnZ2VyIHRoZSBsb2FkaW5nIHNsb3cgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmxvYWRpbmdUaW1lb3V0ICYmICFjYWNoZS5nZXQoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9hZGluZyAmJiBpc0N1cnJlbnRLZXlNb3VudGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uTG9hZGluZ1Nsb3coa2V5LCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY29uZmlnLmxvYWRpbmdUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSByZXF1ZXN0IGFuZCBzYXZlIHRoZSB0aW1lc3RhbXAuXG4gICAgICAgICAgICAgICAgICAgICAgICBGRVRDSFtrZXldID0gW2N1cnJlbnRGZXRjaGVyLmFwcGx5KHZvaWQgMCwgZm5BcmdzKSwgZ2V0VGltZXN0YW1wKCldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9hID0gRkVUQ0hba2V5XSwgbmV3RGF0YSA9IF9hWzBdLCBzdGFydEF0ID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIG5ld0RhdGFdO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgaXNuJ3QgaW50ZXJydXB0ZWQsIGNsZWFuIGl0IHVwIGFmdGVyIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVkdXBsaWNhdGlvbiBpbnRlcnZhbC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2xlYW51cFN0YXRlLCBjb25maWcuZGVkdXBpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncmUgb3RoZXIgb25nb2luZyByZXF1ZXN0KHMpLCBzdGFydGVkIGFmdGVyIHRoZSBjdXJyZW50IG9uZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBpZ25vcmUgdGhlIGN1cnJlbnQgb25lIHRvIGF2b2lkIHBvc3NpYmxlIHJhY2UgY29uZGl0aW9uczpcbiAgICAgICAgICAgICAgICAgICAgLy8gICByZXExLS0tLS0tLS0tLS0tLS0tLS0tPnJlczEgICAgICAgIChjdXJyZW50IG9uZSlcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgIHJlcTItLS0tLS0tLS0tLS0tLS0tPnJlczJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlcXVlc3QgdGhhdCBmaXJlZCBsYXRlciB3aWxsIGFsd2F5cyBiZSBrZXB0LlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdGltZXN0YW1wIG1heWJlIGJlIGB1bmRlZmluZWRgIG9yIGEgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIGlmICghRkVUQ0hba2V5XSB8fCBGRVRDSFtrZXldWzFdICE9PSBzdGFydEF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudEtleU1vdW50ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25maWcoKS5vbkRpc2NhcmRlZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRmV0Y2hJbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBVTkRFRklORURcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLmVycm9yID0gVU5ERUZJTkVEO1xuICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbkluZm8gPSBNVVRBVElPTltrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKG11dGF0aW9uSW5mbykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgMVxuICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXJ0QXQgPD0gbXV0YXRpb25JbmZvWzBdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRBdCA8PSBtdXRhdGlvbkluZm9bMV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbkluZm9bMV0gPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50S2V5TW91bnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uRGlzY2FyZGVkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZhbHNlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBEZWVwIGNvbXBhcmUgd2l0aCBsYXRlc3Qgc3RhdGUgdG8gYXZvaWQgZXh0cmEgcmUtcmVuZGVycy5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGxvY2FsIHN0YXRlLCBjb21wYXJlIGFuZCBhc3NpZ24uXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGFyZShzdGF0ZVJlZi5jdXJyZW50LmRhdGEsIG5ld0RhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZS5kYXRhID0gbmV3RGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRhdGEgYW5kIG5ld0RhdGEgYXJlIGRlZXBseSBlcXVhbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgc2hvdWxkIGJlIHNhZmUgdG8gYnJvYWRjYXN0IHRoZSBzdGFsZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZS5kYXRhID0gc3RhdGVSZWYuY3VycmVudC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXQgdGhlIGVuZCBvZiB0aGlzIGZ1bmN0aW9uLCBgYnJvY2FzdFN0YXRlYCBpbnZva2VzIHRoZSBgb25TdGF0ZVVwZGF0ZWAgZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCB0YWtlcyBjYXJlIG9mIGF2b2lkaW5nIHRoZSByZS1yZW5kZXJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZ2xvYmFsIHN0YXRlLCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGtleSBoYXMgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9zd3IvcHVsbC8xMDU4XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGFyZShjYWNoZS5nZXQoa2V5KSwgbmV3RGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnNldChrZXksIG5ld0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgdGhlIHN1Y2Nlc3NmdWwgY2FsbGJhY2sgaWYgaXQncyB0aGUgb3JpZ2luYWwgcmVxdWVzdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudEtleU1vdW50ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uU3VjY2VzcyhuZXdEYXRhLCBrZXksIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBlcnJfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBwYXVzZWQsIHdlIGNvbnRpbnVlIGhhbmRsaW5nIHRoZSBlcnJvci4gT3RoZXJ3aXNlIGRpc2NhcmQgaXQuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2V0Q29uZmlnKCkuaXNQYXVzZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGEgbmV3IGVycm9yLCBkb24ndCB1c2UgZGVlcCBjb21wYXJpc29uIGZvciBlcnJvcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaEZldGNoSW5mbyh7IGVycm9yOiBlcnJfMSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLmVycm9yID0gZXJyXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFcnJvciBldmVudCBhbmQgcmV0cnkgbG9naWMuIE9ubHkgZm9yIHRoZSBhY3R1YWwgcmVxdWVzdCwgbm90XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWR1cGVkIG9uZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0ICYmIGlzQ3VycmVudEtleU1vdW50ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uRXJyb3IoZXJyXzEsIGtleSwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiBjb25maWcuc2hvdWxkUmV0cnlPbkVycm9yID09PSAnYm9vbGVhbicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnNob3VsZFJldHJ5T25FcnJvcikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlzRnVuY3Rpb24oY29uZmlnLnNob3VsZFJldHJ5T25FcnJvcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5zaG91bGRSZXRyeU9uRXJyb3IoZXJyXzEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHJldHJ5aW5nLCBkZWR1cGUgaXMgYWx3YXlzIGVuYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgYWN0aXZlLCBzdG9wLiBJdCB3aWxsIGF1dG8gcmV2YWxpZGF0ZSB3aGVuIHJlZm9jdXNpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIHJlY29ubmVjdGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uRXJyb3JSZXRyeShlcnJfMSwga2V5LCBjb25maWcsIHJldmFsaWRhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeUNvdW50OiAob3B0cy5yZXRyeUNvdW50IHx8IDApICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWR1cGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFyayBsb2FkaW5nIGFzIHN0b3BwZWQuXG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IGhvb2sncyBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhlcmUgaXMgdGhlIHNvdXJjZSBvZiB0aGUgcmVxdWVzdCwgbmVlZCB0byB0ZWxsIGFsbCBvdGhlciBob29rcyB0b1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlaXIgc3RhdGVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50S2V5TW91bnRlZCgpICYmIHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0U3RhdGUoY2FjaGUsIGtleSwgbmV3U3RhdGUuZGF0YSwgbmV3U3RhdGUuZXJyb3IsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdHJ1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pOyB9LCBcbiAgICAvLyBgc2V0U3RhdGVgIGlzIGltbXV0YWJsZSwgYW5kIGBldmVudHNDYWxsYmFja2AsIGBmbkFyZ3NgLCBga2V5SW5mb2AsXG4gICAgLy8gYW5kIGBrZXlWYWxpZGF0aW5nYCBhcmUgZGVwZW5kaW5nIG9uIGBrZXlgLCBzbyB3ZSBjYW4gZXhjbHVkZSB0aGVtIGZyb21cbiAgICAvLyB0aGUgZGVwcyBhcnJheS5cbiAgICAvL1xuICAgIC8vIEZJWE1FOlxuICAgIC8vIGBmbmAgYW5kIGBjb25maWdgIG1pZ2h0IGJlIGNoYW5nZWQgZHVyaW5nIHRoZSBsaWZlY3ljbGUsXG4gICAgLy8gYnV0IHRoZXkgbWlnaHQgYmUgY2hhbmdlZCBldmVyeSByZW5kZXIgbGlrZSB0aGlzLlxuICAgIC8vIGB1c2VTV1IoJ2tleScsICgpID0+IGZldGNoKCcvYXBpLycpLCB7IHN1c3BlbnNlOiB0cnVlIH0pYFxuICAgIC8vIFNvIHdlIG9taXQgdGhlIHZhbHVlcyBmcm9tIHRoZSBkZXBzIGFycmF5XG4gICAgLy8gZXZlbiB0aG91Z2ggaXQgbWlnaHQgY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvcnMuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtrZXldKTtcbiAgICAvLyBTaW1pbGFyIHRvIHRoZSBnbG9iYWwgbXV0YXRlLCBidXQgYm91bmQgdG8gdGhlIGN1cnJlbnQgY2FjaGUgYW5kIGtleS5cbiAgICAvLyBgY2FjaGVgIGlzbid0IGFsbG93ZWQgdG8gY2hhbmdlIGR1cmluZyB0aGUgbGlmZWN5Y2xlLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB2YXIgYm91bmRNdXRhdGUgPSB1c2VDYWxsYmFjayhcbiAgICAvLyBCeSB1c2luZyBgYmluZGAgd2UgZG9uJ3QgbmVlZCB0byBtb2RpZnkgdGhlIHNpemUgb2YgdGhlIHJlc3QgYXJndW1lbnRzLlxuICAgIC8vIER1ZSB0byBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzM3MTgxLCB3ZSBoYXZlIHRvXG4gICAgLy8gY2FzdCBpdCB0byBhbnkgZm9yIG5vdy5cbiAgICBpbnRlcm5hbE11dGF0ZS5iaW5kKFVOREVGSU5FRCwgY2FjaGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGtleVJlZi5jdXJyZW50OyB9KSwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtdKTtcbiAgICAvLyBBbHdheXMgdXBkYXRlIGZldGNoZXIgYW5kIGNvbmZpZyByZWZzLlxuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBmZXRjaGVyUmVmLmN1cnJlbnQgPSBmZXRjaGVyO1xuICAgICAgICBjb25maWdSZWYuY3VycmVudCA9IGNvbmZpZztcbiAgICB9KTtcbiAgICAvLyBBZnRlciBtb3VudGVkIG9yIGtleSBjaGFuZ2VkLlxuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWtleSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGtleUNoYW5nZWQgPSBrZXkgIT09IGtleVJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgc29mdFJldmFsaWRhdGUgPSByZXZhbGlkYXRlLmJpbmQoVU5ERUZJTkVELCBXSVRIX0RFRFVQRSk7XG4gICAgICAgIC8vIEV4cG9zZSBzdGF0ZSB1cGRhdGVyIHRvIGdsb2JhbCBldmVudCBsaXN0ZW5lcnMuIFNvIHdlIGNhbiB1cGRhdGUgaG9vaydzXG4gICAgICAgIC8vIGludGVybmFsIHN0YXRlIGZyb20gdGhlIG91dHNpZGUuXG4gICAgICAgIHZhciBvblN0YXRlVXBkYXRlID0gZnVuY3Rpb24gKHVwZGF0ZWREYXRhLCB1cGRhdGVkRXJyb3IsIHVwZGF0ZWRJc1ZhbGlkYXRpbmcpIHtcbiAgICAgICAgICAgIHNldFN0YXRlKG1lcmdlT2JqZWN0cyh7XG4gICAgICAgICAgICAgICAgZXJyb3I6IHVwZGF0ZWRFcnJvcixcbiAgICAgICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IHVwZGF0ZWRJc1ZhbGlkYXRpbmdcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLy8gU2luY2UgYHNldFN0YXRlYCBvbmx5IHNoYWxsb3dseSBjb21wYXJlcyBzdGF0ZXMsIHdlIGRvIGEgZGVlcFxuICAgICAgICAgICAgLy8gY29tcGFyaXNvbiBoZXJlLlxuICAgICAgICAgICAgY29tcGFyZShzdGF0ZVJlZi5jdXJyZW50LmRhdGEsIHVwZGF0ZWREYXRhKVxuICAgICAgICAgICAgICAgID8gVU5ERUZJTkVEXG4gICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHVwZGF0ZWREYXRhXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBFeHBvc2UgcmV2YWxpZGF0b3JzIHRvIGdsb2JhbCBldmVudCBsaXN0ZW5lcnMuIFNvIHdlIGNhbiB0cmlnZ2VyXG4gICAgICAgIC8vIHJldmFsaWRhdGlvbiBmcm9tIHRoZSBvdXRzaWRlLlxuICAgICAgICB2YXIgbmV4dEZvY3VzUmV2YWxpZGF0ZWRBdCA9IDA7XG4gICAgICAgIHZhciBvblJldmFsaWRhdGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gRk9DVVNfRVZFTlQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0Q29uZmlnKCkucmV2YWxpZGF0ZU9uRm9jdXMgJiZcbiAgICAgICAgICAgICAgICAgICAgbm93ID4gbmV4dEZvY3VzUmV2YWxpZGF0ZWRBdCAmJlxuICAgICAgICAgICAgICAgICAgICBpc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRGb2N1c1JldmFsaWRhdGVkQXQgPSBub3cgKyBnZXRDb25maWcoKS5mb2N1c1Rocm90dGxlSW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgIHNvZnRSZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBSRUNPTk5FQ1RfRVZFTlQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0Q29uZmlnKCkucmV2YWxpZGF0ZU9uUmVjb25uZWN0ICYmIGlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc29mdFJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IE1VVEFURV9FVkVOVCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIHZhciB1bnN1YlVwZGF0ZSA9IHN1YnNjcmliZUNhbGxiYWNrKGtleSwgU1RBVEVfVVBEQVRFUlMsIG9uU3RhdGVVcGRhdGUpO1xuICAgICAgICB2YXIgdW5zdWJFdmVudHMgPSBzdWJzY3JpYmVDYWxsYmFjayhrZXksIEVWRU5UX1JFVkFMSURBVE9SUywgb25SZXZhbGlkYXRlKTtcbiAgICAgICAgLy8gTWFyayB0aGUgY29tcG9uZW50IGFzIG1vdW50ZWQgYW5kIHVwZGF0ZSBjb3JyZXNwb25kaW5nIHJlZnMuXG4gICAgICAgIHVubW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIGtleVJlZi5jdXJyZW50ID0ga2V5O1xuICAgICAgICBpbml0aWFsTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgLy8gV2hlbiBga2V5YCB1cGRhdGVzLCByZXNldCB0aGUgc3RhdGUgdG8gdGhlIGluaXRpYWwgdmFsdWVcbiAgICAgICAgLy8gYW5kIHRyaWdnZXIgYSByZXJlbmRlciBpZiBuZWNlc3NhcnkuXG4gICAgICAgIGlmIChrZXlDaGFuZ2VkKSB7XG4gICAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiBpc1ZhbGlkYXRpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyaWdnZXIgYSByZXZhbGlkYXRpb24uXG4gICAgICAgIGlmIChzaG91bGRSZXZhbGlkYXRlKCkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChkYXRhKSB8fCBJU19TRVJWRVIpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXZhbGlkYXRlIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgICAgIHNvZnRSZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEZWxheSB0aGUgcmV2YWxpZGF0ZSBpZiB3ZSBoYXZlIGRhdGEgdG8gcmV0dXJuIHNvIHdlIHdvbid0IGJsb2NrXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyaW5nLlxuICAgICAgICAgICAgICAgIHJBRihzb2Z0UmV2YWxpZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE1hcmsgaXQgYXMgdW5tb3VudGVkLlxuICAgICAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdW5zdWJVcGRhdGUoKTtcbiAgICAgICAgICAgIHVuc3ViRXZlbnRzKCk7XG4gICAgICAgIH07XG4gICAgfSwgW2tleSwgcmV2YWxpZGF0ZV0pO1xuICAgIC8vIFBvbGxpbmdcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRpbWVyO1xuICAgICAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBwYXNzZWQgaW50ZXJ2YWxcbiAgICAgICAgICAgIC8vIC4uLm9yIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgdXBkYXRlZCBkYXRhIHRvIGdldCB0aGUgaW50ZXJ2YWxcbiAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IGlzRnVuY3Rpb24ocmVmcmVzaEludGVydmFsKVxuICAgICAgICAgICAgICAgID8gcmVmcmVzaEludGVydmFsKGRhdGEpXG4gICAgICAgICAgICAgICAgOiByZWZyZXNoSW50ZXJ2YWw7XG4gICAgICAgICAgICAvLyBXZSBvbmx5IHN0YXJ0IG5leHQgaW50ZXJ2YWwgaWYgYHJlZnJlc2hJbnRlcnZhbGAgaXMgbm90IDAsIGFuZDpcbiAgICAgICAgICAgIC8vIC0gYGZvcmNlYCBpcyB0cnVlLCB3aGljaCBpcyB0aGUgc3RhcnQgb2YgcG9sbGluZ1xuICAgICAgICAgICAgLy8gLSBvciBgdGltZXJgIGlzIG5vdCAwLCB3aGljaCBtZWFucyB0aGUgZWZmZWN0IHdhc24ndCBjYW5jZWxlZFxuICAgICAgICAgICAgaWYgKGludGVydmFsICYmIHRpbWVyICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChleGVjdXRlLCBpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXhlY3V0ZSgpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgT0sgdG8gZXhlY3V0ZTpcbiAgICAgICAgICAgIC8vIE9ubHkgcmV2YWxpZGF0ZSB3aGVuIHRoZSBwYWdlIGlzIHZpc2libGUsIG9ubGluZSBhbmQgbm90IGVycm9yZWQuXG4gICAgICAgICAgICBpZiAoIXN0YXRlUmVmLmN1cnJlbnQuZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAocmVmcmVzaFdoZW5IaWRkZW4gfHwgZ2V0Q29uZmlnKCkuaXNWaXNpYmxlKCkpICYmXG4gICAgICAgICAgICAgICAgKHJlZnJlc2hXaGVuT2ZmbGluZSB8fCBnZXRDb25maWcoKS5pc09ubGluZSgpKSkge1xuICAgICAgICAgICAgICAgIHJldmFsaWRhdGUoV0lUSF9ERURVUEUpLnRoZW4obmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTY2hlZHVsZSBuZXh0IGludGVydmFsIHRvIGNoZWNrIGFnYWluLlxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIHRpbWVyID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW3JlZnJlc2hJbnRlcnZhbCwgcmVmcmVzaFdoZW5IaWRkZW4sIHJlZnJlc2hXaGVuT2ZmbGluZSwgcmV2YWxpZGF0ZV0pO1xuICAgIC8vIERpc3BsYXkgZGVidWcgaW5mbyBpbiBSZWFjdCBEZXZUb29scy5cbiAgICB1c2VEZWJ1Z1ZhbHVlKGRhdGEpO1xuICAgIC8vIEluIFN1c3BlbnNlIG1vZGUsIHdlIGNhbid0IHJldHVybiB0aGUgZW1wdHkgYGRhdGFgIHN0YXRlLlxuICAgIC8vIElmIHRoZXJlIGlzIGBlcnJvcmAsIHRoZSBgZXJyb3JgIG5lZWRzIHRvIGJlIHRocm93biB0byB0aGUgZXJyb3IgYm91bmRhcnkuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYGVycm9yYCwgdGhlIGByZXZhbGlkYXRpb25gIHByb21pc2UgbmVlZHMgdG8gYmUgdGhyb3duIHRvXG4gICAgLy8gdGhlIHN1c3BlbnNlIGJvdW5kYXJ5LlxuICAgIGlmIChzdXNwZW5zZSAmJiBpc1VuZGVmaW5lZChkYXRhKSAmJiBrZXkpIHtcbiAgICAgICAgLy8gQWx3YXlzIHVwZGF0ZSBmZXRjaGVyIGFuZCBjb25maWcgcmVmcyBldmVuIHdpdGggdGhlIFN1c3BlbnNlIG1vZGUuXG4gICAgICAgIGZldGNoZXJSZWYuY3VycmVudCA9IGZldGNoZXI7XG4gICAgICAgIGNvbmZpZ1JlZi5jdXJyZW50ID0gY29uZmlnO1xuICAgICAgICB1bm1vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB0aHJvdyBpc1VuZGVmaW5lZChlcnJvcikgPyByZXZhbGlkYXRlKFdJVEhfREVEVVBFKSA6IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtdXRhdGU6IGJvdW5kTXV0YXRlLFxuICAgICAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgICAgIHN0YXRlRGVwZW5kZW5jaWVzLmRhdGEgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgIHN0YXRlRGVwZW5kZW5jaWVzLmVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGlzVmFsaWRhdGluZygpIHtcbiAgICAgICAgICAgIHN0YXRlRGVwZW5kZW5jaWVzLmlzVmFsaWRhdGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gaXNWYWxpZGF0aW5nO1xuICAgICAgICB9XG4gICAgfTtcbn07XG52YXIgU1dSQ29uZmlnID0gT0JKRUNULmRlZmluZVByb3BlcnR5KFNXUkNvbmZpZyQxLCAnZGVmYXVsdCcsIHtcbiAgICB2YWx1ZTogZGVmYXVsdENvbmZpZ1xufSk7XG52YXIgdW5zdGFibGVfc2VyaWFsaXplID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gc2VyaWFsaXplKGtleSlbMF07IH07XG52YXIgdXNlU1dSID0gd2l0aEFyZ3ModXNlU1dSSGFuZGxlcik7XG5cbi8vIHVzZVNXUlxuXG5leHBvcnQgeyBTV1JDb25maWcsIHVzZVNXUiBhcyBkZWZhdWx0LCBtdXRhdGUsIHVuc3RhYmxlX3NlcmlhbGl6ZSwgdXNlU1dSQ29uZmlnIH07XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsImNyZWF0ZUVsZW1lbnQiLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsInVzZURlYnVnVmFsdWUiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJfX2dlbmVyYXRvciIsImJvZHkiLCJfIiwibGFiZWwiLCJzZW50IiwidCIsInRyeXMiLCJvcHMiLCJmIiwieSIsImciLCJ2ZXJiIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJuIiwidiIsIm9wIiwiVHlwZUVycm9yIiwiY2FsbCIsInBvcCIsImxlbmd0aCIsInB1c2giLCJub29wIiwiVU5ERUZJTkVEIiwiT0JKRUNUIiwiT2JqZWN0IiwiaXNVbmRlZmluZWQiLCJpc0Z1bmN0aW9uIiwibWVyZ2VPYmplY3RzIiwiYSIsImIiLCJhc3NpZ24iLCJTVFJfVU5ERUZJTkVEIiwiaGFzV2luZG93IiwiaGFzRG9jdW1lbnQiLCJkb2N1bWVudCIsImhhc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIndpbmRvdyIsInRhYmxlIiwiV2Vha01hcCIsImNvdW50ZXIiLCJzdGFibGVIYXNoIiwiYXJnIiwidHlwZSIsImNvbnN0cnVjdG9yIiwiaXNEYXRlIiwiRGF0ZSIsImluZGV4IiwiUmVnRXhwIiwiZ2V0Iiwic2V0IiwiQXJyYXkiLCJrZXlzIiwic29ydCIsInRvSlNPTiIsInRvU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsIm9ubGluZSIsImlzT25saW5lIiwiaGFzV2luIiwiaGFzRG9jIiwib25XaW5kb3dFdmVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJiaW5kIiwib25Eb2N1bWVudEV2ZW50Iiwib2ZmV2luZG93RXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib2ZmRG9jdW1lbnRFdmVudCIsImlzVmlzaWJsZSIsInZpc2liaWxpdHlTdGF0ZSIsImluaXRGb2N1cyIsImNhbGxiYWNrIiwiaW5pdFJlY29ubmVjdCIsIm9uT25saW5lIiwib25PZmZsaW5lIiwicHJlc2V0IiwiZGVmYXVsdENvbmZpZ09wdGlvbnMiLCJJU19TRVJWRVIiLCJyQUYiLCJzZXRUaW1lb3V0IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsIm5hdmlnYXRvckNvbm5lY3Rpb24iLCJuYXZpZ2F0b3IiLCJjb25uZWN0aW9uIiwic2xvd0Nvbm5lY3Rpb24iLCJpbmNsdWRlcyIsImVmZmVjdGl2ZVR5cGUiLCJzYXZlRGF0YSIsInNlcmlhbGl6ZSIsImtleSIsImVyciIsImFyZ3MiLCJjb25jYXQiLCJpc0FycmF5IiwiaW5mb0tleSIsIlNXUkdsb2JhbFN0YXRlIiwiRk9DVVNfRVZFTlQiLCJSRUNPTk5FQ1RfRVZFTlQiLCJNVVRBVEVfRVZFTlQiLCJicm9hZGNhc3RTdGF0ZSIsImNhY2hlIiwiZGF0YSIsImVycm9yIiwiaXNWYWxpZGF0aW5nIiwicmV2YWxpZGF0ZSIsImJyb2FkY2FzdCIsIl9hIiwiRVZFTlRfUkVWQUxJREFUT1JTIiwiU1RBVEVfVVBEQVRFUlMiLCJGRVRDSCIsInJldmFsaWRhdG9ycyIsInVwZGF0ZXJzIiwiaSIsIl9fdGltZXN0YW1wIiwiZ2V0VGltZXN0YW1wIiwiaW50ZXJuYWxNdXRhdGUiLCJfaSIsImFyZ3VtZW50cyIsIl9rZXkiLCJfZGF0YSIsIl9vcHRzIiwib3B0aW9ucyIsInBvcHVsYXRlQ2FjaGUiLCJyb2xsYmFja09uRXJyb3IiLCJjdXN0b21PcHRpbWlzdGljRGF0YSIsImtleUluZm8iLCJfYiIsIk1VVEFUSU9OIiwiYmVmb3JlTXV0YXRpb25UcyIsImhhc0N1c3RvbU9wdGltaXN0aWNEYXRhIiwicm9sbGJhY2tEYXRhIiwib3B0aW1pc3RpY0RhdGEiLCJyZXMiLCJfYyIsImNhdGNoIiwicmV2YWxpZGF0ZUFsbEtleXMiLCJpbml0Q2FjaGUiLCJwcm92aWRlciIsImhhcyIsIm9wdHMiLCJtdXRhdGUiLCJ1bm1vdW50IiwicmVsZWFzZUZvY3VzXzEiLCJyZWxlYXNlUmVjb25uZWN0XzEiLCJkZWxldGUiLCJvbkVycm9yUmV0cnkiLCJfXyIsImNvbmZpZyIsIm1heFJldHJ5Q291bnQiLCJlcnJvclJldHJ5Q291bnQiLCJjdXJyZW50UmV0cnlDb3VudCIsInJldHJ5Q291bnQiLCJ0aW1lb3V0IiwiTWF0aCIsInJhbmRvbSIsImVycm9yUmV0cnlJbnRlcnZhbCIsIk1hcCIsImRlZmF1bHRDb25maWciLCJvbkxvYWRpbmdTbG93Iiwib25TdWNjZXNzIiwib25FcnJvciIsIm9uRGlzY2FyZGVkIiwicmV2YWxpZGF0ZU9uRm9jdXMiLCJyZXZhbGlkYXRlT25SZWNvbm5lY3QiLCJyZXZhbGlkYXRlSWZTdGFsZSIsInNob3VsZFJldHJ5T25FcnJvciIsImZvY3VzVGhyb3R0bGVJbnRlcnZhbCIsImRlZHVwaW5nSW50ZXJ2YWwiLCJsb2FkaW5nVGltZW91dCIsImNvbXBhcmUiLCJjdXJyZW50RGF0YSIsIm5ld0RhdGEiLCJpc1BhdXNlZCIsImZhbGxiYWNrIiwibWVyZ2VDb25maWdzIiwidTEiLCJ1c2UiLCJmMSIsInUyIiwiZjIiLCJTV1JDb25maWdDb250ZXh0IiwiU1dSQ29uZmlnJDEiLCJwcm9wcyIsImV4dGVuZGVkQ29uZmlnIiwiY2FjaGVDb250ZXh0IiwiUHJvdmlkZXIiLCJ1c2VTdGF0ZVdpdGhEZXBzIiwic3RhdGUiLCJ1bm1vdW50ZWRSZWYiLCJyZXJlbmRlciIsInN0YXRlUmVmIiwic3RhdGVEZXBlbmRlbmNpZXNSZWYiLCJzZXRTdGF0ZSIsInBheWxvYWQiLCJzaG91bGRSZXJlbmRlciIsImN1cnJlbnRTdGF0ZSIsImN1cnJlbnQiLCJrIiwibm9ybWFsaXplIiwidXNlU1dSQ29uZmlnIiwid2l0aEFyZ3MiLCJob29rIiwidXNlU1dSQXJncyIsImZhbGxiYWNrQ29uZmlnIiwiZm4iLCJfY29uZmlnIiwiZmV0Y2hlciIsInN1YnNjcmliZUNhbGxiYWNrIiwiY2FsbGJhY2tzIiwia2V5ZWRSZXZhbGlkYXRvcnMiLCJpbmRleE9mIiwiV0lUSF9ERURVUEUiLCJkZWR1cGUiLCJ1c2VTV1JIYW5kbGVyIiwiZmFsbGJhY2tEYXRhIiwic3VzcGVuc2UiLCJyZXZhbGlkYXRlT25Nb3VudCIsInJlZnJlc2hJbnRlcnZhbCIsInJlZnJlc2hXaGVuSGlkZGVuIiwicmVmcmVzaFdoZW5PZmZsaW5lIiwiZm5BcmdzIiwiaW5pdGlhbE1vdW50ZWRSZWYiLCJrZXlSZWYiLCJmZXRjaGVyUmVmIiwiY29uZmlnUmVmIiwiZ2V0Q29uZmlnIiwiaXNBY3RpdmUiLCJwYXRjaEZldGNoSW5mbyIsImluZm8iLCJjYWNoZWQiLCJpc0luaXRpYWxNb3VudCIsInNob3VsZFJldmFsaWRhdGUiLCJyZXNvbHZlVmFsaWRhdGluZyIsInN0YXRlRGVwZW5kZW5jaWVzIiwicmV2YWxpZGF0ZU9wdHMiLCJjdXJyZW50RmV0Y2hlciIsInN0YXJ0QXQiLCJsb2FkaW5nIiwic2hvdWxkU3RhcnROZXdSZXF1ZXN0IiwiaXNDdXJyZW50S2V5TW91bnRlZCIsImNsZWFudXBTdGF0ZSIsIm5ld1N0YXRlIiwiZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlIiwibXV0YXRpb25JbmZvIiwiZXJyXzEiLCJyZXF1ZXN0SW5mbyIsImJvdW5kTXV0YXRlIiwia2V5Q2hhbmdlZCIsInNvZnRSZXZhbGlkYXRlIiwib25TdGF0ZVVwZGF0ZSIsInVwZGF0ZWREYXRhIiwidXBkYXRlZEVycm9yIiwidXBkYXRlZElzVmFsaWRhdGluZyIsIm5leHRGb2N1c1JldmFsaWRhdGVkQXQiLCJvblJldmFsaWRhdGUiLCJub3ciLCJ1bnN1YlVwZGF0ZSIsInVuc3ViRXZlbnRzIiwidGltZXIiLCJpbnRlcnZhbCIsImV4ZWN1dGUiLCJjbGVhclRpbWVvdXQiLCJTV1JDb25maWciLCJkZWZpbmVQcm9wZXJ0eSIsInVuc3RhYmxlX3NlcmlhbGl6ZSIsInVzZVNXUiIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/swr/dist/index.mjs\n");

/***/ })

};
;